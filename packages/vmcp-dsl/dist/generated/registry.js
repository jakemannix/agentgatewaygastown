"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: registry.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaMapSpec = exports.ValueList = exports.PredicateValue = exports.FieldPredicate = exports.FilterSpec = exports.LimitOp = exports.DedupeOp = exports.SortOp = exports.AggregationOp = exports.AggregationStrategy = exports.ScatterTarget = exports.ScatterGatherSpec = exports.ConstructBinding_FieldsEntry = exports.ConstructBinding = exports.StepBinding = exports.InputBinding = exports.DataBinding = exports.ToolCall = exports.AgentCall = exports.StepOperation = exports.PipelineStep = exports.PipelineSpec = exports.PatternSpec = exports.SourceTool_DefaultsEntry = exports.SourceTool = exports.ToolDefinition_MetadataEntry = exports.ToolDefinition = exports.ServerDependency = exports.AgentDependency = exports.SkillExample = exports.SchemaRef = exports.AgentSkill = exports.OAuth2Auth = exports.ApiKeyAuth = exports.BearerAuth = exports.AgentAuth = exports.MCPEndpoint = exports.A2AEndpoint = exports.AgentEndpoint = exports.AgentDefinition_MetadataEntry = exports.AgentDefinition = exports.ServerTool = exports.ServerCapabilities = exports.ServerDefinition_MetadataEntry = exports.ServerDefinition = exports.SchemaDefinition_MetadataEntry = exports.SchemaDefinition = exports.Registry = exports.OnDuplicate = exports.protobufPackage = void 0;
exports.ClaimCheckSpec = exports.SagaStep = exports.SagaSpec = exports.DeadLetterSpec = exports.CircuitBreakerSpec = exports.IdempotentSpec = exports.CacheSpec = exports.TimeoutSpec = exports.LinearBackoff = exports.ExponentialBackoff = exports.FixedBackoff = exports.BackoffStrategy = exports.RetrySpec = exports.OutputTransform_MappingsEntry = exports.OutputTransform = exports.MapEachInner = exports.MapEachSpec = exports.ConcatSource = exports.TemplateSource_VarsEntry = exports.TemplateSource = exports.CoalesceSource = exports.LiteralValue = exports.FieldSource = exports.SchemaMapSpec_MappingsEntry = void 0;
exports.onDuplicateFromJSON = onDuplicateFromJSON;
exports.onDuplicateToJSON = onDuplicateToJSON;
/* eslint-disable */
exports.protobufPackage = "agentgateway.dev.registry";
var OnDuplicate;
(function (OnDuplicate) {
    OnDuplicate["ON_DUPLICATE_UNSPECIFIED"] = "ON_DUPLICATE_UNSPECIFIED";
    /** ON_DUPLICATE_CACHED - Return cached result */
    OnDuplicate["ON_DUPLICATE_CACHED"] = "ON_DUPLICATE_CACHED";
    /** ON_DUPLICATE_SKIP - Return null/empty */
    OnDuplicate["ON_DUPLICATE_SKIP"] = "ON_DUPLICATE_SKIP";
    /** ON_DUPLICATE_ERROR - Return error */
    OnDuplicate["ON_DUPLICATE_ERROR"] = "ON_DUPLICATE_ERROR";
    OnDuplicate["UNRECOGNIZED"] = "UNRECOGNIZED";
})(OnDuplicate || (exports.OnDuplicate = OnDuplicate = {}));
function onDuplicateFromJSON(object) {
    switch (object) {
        case 0:
        case "ON_DUPLICATE_UNSPECIFIED":
            return OnDuplicate.ON_DUPLICATE_UNSPECIFIED;
        case 1:
        case "ON_DUPLICATE_CACHED":
            return OnDuplicate.ON_DUPLICATE_CACHED;
        case 2:
        case "ON_DUPLICATE_SKIP":
            return OnDuplicate.ON_DUPLICATE_SKIP;
        case 3:
        case "ON_DUPLICATE_ERROR":
            return OnDuplicate.ON_DUPLICATE_ERROR;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OnDuplicate.UNRECOGNIZED;
    }
}
function onDuplicateToJSON(object) {
    switch (object) {
        case OnDuplicate.ON_DUPLICATE_UNSPECIFIED:
            return "ON_DUPLICATE_UNSPECIFIED";
        case OnDuplicate.ON_DUPLICATE_CACHED:
            return "ON_DUPLICATE_CACHED";
        case OnDuplicate.ON_DUPLICATE_SKIP:
            return "ON_DUPLICATE_SKIP";
        case OnDuplicate.ON_DUPLICATE_ERROR:
            return "ON_DUPLICATE_ERROR";
        case OnDuplicate.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseRegistry() {
    return { schemaVersion: "", tools: [], schemas: [], servers: [], agents: [] };
}
exports.Registry = {
    fromJSON(object) {
        return {
            schemaVersion: isSet(object.schemaVersion)
                ? globalThis.String(object.schemaVersion)
                : isSet(object.schema_version)
                    ? globalThis.String(object.schema_version)
                    : "",
            tools: globalThis.Array.isArray(object?.tools)
                ? object.tools.map((e) => exports.ToolDefinition.fromJSON(e))
                : [],
            schemas: globalThis.Array.isArray(object?.schemas)
                ? object.schemas.map((e) => exports.SchemaDefinition.fromJSON(e))
                : [],
            servers: globalThis.Array.isArray(object?.servers)
                ? object.servers.map((e) => exports.ServerDefinition.fromJSON(e))
                : [],
            agents: globalThis.Array.isArray(object?.agents)
                ? object.agents.map((e) => exports.AgentDefinition.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.schemaVersion !== "") {
            obj.schemaVersion = message.schemaVersion;
        }
        if (message.tools?.length) {
            obj.tools = message.tools.map((e) => exports.ToolDefinition.toJSON(e));
        }
        if (message.schemas?.length) {
            obj.schemas = message.schemas.map((e) => exports.SchemaDefinition.toJSON(e));
        }
        if (message.servers?.length) {
            obj.servers = message.servers.map((e) => exports.ServerDefinition.toJSON(e));
        }
        if (message.agents?.length) {
            obj.agents = message.agents.map((e) => exports.AgentDefinition.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.Registry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRegistry();
        message.schemaVersion = object.schemaVersion ?? "";
        message.tools = object.tools?.map((e) => exports.ToolDefinition.fromPartial(e)) || [];
        message.schemas = object.schemas?.map((e) => exports.SchemaDefinition.fromPartial(e)) || [];
        message.servers = object.servers?.map((e) => exports.ServerDefinition.fromPartial(e)) || [];
        message.agents = object.agents?.map((e) => exports.AgentDefinition.fromPartial(e)) || [];
        return message;
    },
};
function createBaseSchemaDefinition() {
    return { name: "", description: undefined, schema: undefined, version: undefined, metadata: {} };
}
exports.SchemaDefinition = {
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
            schema: isObject(object.schema) ? object.schema : undefined,
            version: isSet(object.version) ? globalThis.String(object.version) : undefined,
            metadata: isObject(object.metadata)
                ? globalThis.Object.entries(object.metadata).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.schema !== undefined) {
            obj.schema = message.schema;
        }
        if (message.version !== undefined) {
            obj.version = message.version;
        }
        if (message.metadata) {
            const entries = globalThis.Object.entries(message.metadata);
            if (entries.length > 0) {
                obj.metadata = {};
                entries.forEach(([k, v]) => {
                    obj.metadata[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.SchemaDefinition.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSchemaDefinition();
        message.name = object.name ?? "";
        message.description = object.description ?? undefined;
        message.schema = object.schema ?? undefined;
        message.version = object.version ?? undefined;
        message.metadata = globalThis.Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseSchemaDefinition_MetadataEntry() {
    return { key: "", value: undefined };
}
exports.SchemaDefinition_MetadataEntry = {
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.SchemaDefinition_MetadataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSchemaDefinition_MetadataEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseServerDefinition() {
    return { name: "", version: "", description: undefined, capabilities: undefined, providedTools: [], metadata: {} };
}
exports.ServerDefinition = {
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            version: isSet(object.version) ? globalThis.String(object.version) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
            capabilities: isSet(object.capabilities) ? exports.ServerCapabilities.fromJSON(object.capabilities) : undefined,
            providedTools: globalThis.Array.isArray(object?.providedTools)
                ? object.providedTools.map((e) => exports.ServerTool.fromJSON(e))
                : globalThis.Array.isArray(object?.provided_tools)
                    ? object.provided_tools.map((e) => exports.ServerTool.fromJSON(e))
                    : [],
            metadata: isObject(object.metadata)
                ? globalThis.Object.entries(object.metadata).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.capabilities !== undefined) {
            obj.capabilities = exports.ServerCapabilities.toJSON(message.capabilities);
        }
        if (message.providedTools?.length) {
            obj.providedTools = message.providedTools.map((e) => exports.ServerTool.toJSON(e));
        }
        if (message.metadata) {
            const entries = globalThis.Object.entries(message.metadata);
            if (entries.length > 0) {
                obj.metadata = {};
                entries.forEach(([k, v]) => {
                    obj.metadata[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.ServerDefinition.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseServerDefinition();
        message.name = object.name ?? "";
        message.version = object.version ?? "";
        message.description = object.description ?? undefined;
        message.capabilities = (object.capabilities !== undefined && object.capabilities !== null)
            ? exports.ServerCapabilities.fromPartial(object.capabilities)
            : undefined;
        message.providedTools = object.providedTools?.map((e) => exports.ServerTool.fromPartial(e)) || [];
        message.metadata = globalThis.Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseServerDefinition_MetadataEntry() {
    return { key: "", value: undefined };
}
exports.ServerDefinition_MetadataEntry = {
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.ServerDefinition_MetadataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseServerDefinition_MetadataEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseServerCapabilities() {
    return {
        streamableHttp: false,
        stdio: false,
        sse: false,
        tools: false,
        prompts: false,
        resources: false,
        sampling: false,
    };
}
exports.ServerCapabilities = {
    fromJSON(object) {
        return {
            streamableHttp: isSet(object.streamableHttp)
                ? globalThis.Boolean(object.streamableHttp)
                : isSet(object.streamable_http)
                    ? globalThis.Boolean(object.streamable_http)
                    : false,
            stdio: isSet(object.stdio) ? globalThis.Boolean(object.stdio) : false,
            sse: isSet(object.sse) ? globalThis.Boolean(object.sse) : false,
            tools: isSet(object.tools) ? globalThis.Boolean(object.tools) : false,
            prompts: isSet(object.prompts) ? globalThis.Boolean(object.prompts) : false,
            resources: isSet(object.resources) ? globalThis.Boolean(object.resources) : false,
            sampling: isSet(object.sampling) ? globalThis.Boolean(object.sampling) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.streamableHttp !== false) {
            obj.streamableHttp = message.streamableHttp;
        }
        if (message.stdio !== false) {
            obj.stdio = message.stdio;
        }
        if (message.sse !== false) {
            obj.sse = message.sse;
        }
        if (message.tools !== false) {
            obj.tools = message.tools;
        }
        if (message.prompts !== false) {
            obj.prompts = message.prompts;
        }
        if (message.resources !== false) {
            obj.resources = message.resources;
        }
        if (message.sampling !== false) {
            obj.sampling = message.sampling;
        }
        return obj;
    },
    create(base) {
        return exports.ServerCapabilities.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseServerCapabilities();
        message.streamableHttp = object.streamableHttp ?? false;
        message.stdio = object.stdio ?? false;
        message.sse = object.sse ?? false;
        message.tools = object.tools ?? false;
        message.prompts = object.prompts ?? false;
        message.resources = object.resources ?? false;
        message.sampling = object.sampling ?? false;
        return message;
    },
};
function createBaseServerTool() {
    return { name: "", inputSchemaRef: undefined, outputSchemaRef: undefined };
}
exports.ServerTool = {
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            inputSchemaRef: isSet(object.inputSchemaRef)
                ? globalThis.String(object.inputSchemaRef)
                : isSet(object.input_schema_ref)
                    ? globalThis.String(object.input_schema_ref)
                    : undefined,
            outputSchemaRef: isSet(object.outputSchemaRef)
                ? globalThis.String(object.outputSchemaRef)
                : isSet(object.output_schema_ref)
                    ? globalThis.String(object.output_schema_ref)
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.inputSchemaRef !== undefined) {
            obj.inputSchemaRef = message.inputSchemaRef;
        }
        if (message.outputSchemaRef !== undefined) {
            obj.outputSchemaRef = message.outputSchemaRef;
        }
        return obj;
    },
    create(base) {
        return exports.ServerTool.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseServerTool();
        message.name = object.name ?? "";
        message.inputSchemaRef = object.inputSchemaRef ?? undefined;
        message.outputSchemaRef = object.outputSchemaRef ?? undefined;
        return message;
    },
};
function createBaseAgentDefinition() {
    return {
        name: "",
        version: "",
        description: undefined,
        endpoint: undefined,
        skills: [],
        dependencies: [],
        metadata: {},
    };
}
exports.AgentDefinition = {
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            version: isSet(object.version) ? globalThis.String(object.version) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
            endpoint: isSet(object.endpoint) ? exports.AgentEndpoint.fromJSON(object.endpoint) : undefined,
            skills: globalThis.Array.isArray(object?.skills) ? object.skills.map((e) => exports.AgentSkill.fromJSON(e)) : [],
            dependencies: globalThis.Array.isArray(object?.dependencies)
                ? object.dependencies.map((e) => exports.AgentDependency.fromJSON(e))
                : [],
            metadata: isObject(object.metadata)
                ? globalThis.Object.entries(object.metadata).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.endpoint !== undefined) {
            obj.endpoint = exports.AgentEndpoint.toJSON(message.endpoint);
        }
        if (message.skills?.length) {
            obj.skills = message.skills.map((e) => exports.AgentSkill.toJSON(e));
        }
        if (message.dependencies?.length) {
            obj.dependencies = message.dependencies.map((e) => exports.AgentDependency.toJSON(e));
        }
        if (message.metadata) {
            const entries = globalThis.Object.entries(message.metadata);
            if (entries.length > 0) {
                obj.metadata = {};
                entries.forEach(([k, v]) => {
                    obj.metadata[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.AgentDefinition.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAgentDefinition();
        message.name = object.name ?? "";
        message.version = object.version ?? "";
        message.description = object.description ?? undefined;
        message.endpoint = (object.endpoint !== undefined && object.endpoint !== null)
            ? exports.AgentEndpoint.fromPartial(object.endpoint)
            : undefined;
        message.skills = object.skills?.map((e) => exports.AgentSkill.fromPartial(e)) || [];
        message.dependencies = object.dependencies?.map((e) => exports.AgentDependency.fromPartial(e)) || [];
        message.metadata = globalThis.Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseAgentDefinition_MetadataEntry() {
    return { key: "", value: undefined };
}
exports.AgentDefinition_MetadataEntry = {
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.AgentDefinition_MetadataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAgentDefinition_MetadataEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseAgentEndpoint() {
    return { transport: undefined };
}
exports.AgentEndpoint = {
    fromJSON(object) {
        return {
            transport: isSet(object.a2a)
                ? { $case: "a2a", a2a: exports.A2AEndpoint.fromJSON(object.a2a) }
                : isSet(object.mcp)
                    ? { $case: "mcp", mcp: exports.MCPEndpoint.fromJSON(object.mcp) }
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transport?.$case === "a2a") {
            obj.a2a = exports.A2AEndpoint.toJSON(message.transport.a2a);
        }
        else if (message.transport?.$case === "mcp") {
            obj.mcp = exports.MCPEndpoint.toJSON(message.transport.mcp);
        }
        return obj;
    },
    create(base) {
        return exports.AgentEndpoint.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAgentEndpoint();
        switch (object.transport?.$case) {
            case "a2a": {
                if (object.transport?.a2a !== undefined && object.transport?.a2a !== null) {
                    message.transport = { $case: "a2a", a2a: exports.A2AEndpoint.fromPartial(object.transport.a2a) };
                }
                break;
            }
            case "mcp": {
                if (object.transport?.mcp !== undefined && object.transport?.mcp !== null) {
                    message.transport = { $case: "mcp", mcp: exports.MCPEndpoint.fromPartial(object.transport.mcp) };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseA2AEndpoint() {
    return { url: "", auth: undefined };
}
exports.A2AEndpoint = {
    fromJSON(object) {
        return {
            url: isSet(object.url) ? globalThis.String(object.url) : "",
            auth: isSet(object.auth) ? exports.AgentAuth.fromJSON(object.auth) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.url !== "") {
            obj.url = message.url;
        }
        if (message.auth !== undefined) {
            obj.auth = exports.AgentAuth.toJSON(message.auth);
        }
        return obj;
    },
    create(base) {
        return exports.A2AEndpoint.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseA2AEndpoint();
        message.url = object.url ?? "";
        message.auth = (object.auth !== undefined && object.auth !== null) ? exports.AgentAuth.fromPartial(object.auth) : undefined;
        return message;
    },
};
function createBaseMCPEndpoint() {
    return { server: "", serverVersion: undefined };
}
exports.MCPEndpoint = {
    fromJSON(object) {
        return {
            server: isSet(object.server) ? globalThis.String(object.server) : "",
            serverVersion: isSet(object.serverVersion)
                ? globalThis.String(object.serverVersion)
                : isSet(object.server_version)
                    ? globalThis.String(object.server_version)
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.server !== "") {
            obj.server = message.server;
        }
        if (message.serverVersion !== undefined) {
            obj.serverVersion = message.serverVersion;
        }
        return obj;
    },
    create(base) {
        return exports.MCPEndpoint.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMCPEndpoint();
        message.server = object.server ?? "";
        message.serverVersion = object.serverVersion ?? undefined;
        return message;
    },
};
function createBaseAgentAuth() {
    return { authType: undefined };
}
exports.AgentAuth = {
    fromJSON(object) {
        return {
            authType: isSet(object.bearer)
                ? { $case: "bearer", bearer: exports.BearerAuth.fromJSON(object.bearer) }
                : isSet(object.apiKey)
                    ? { $case: "apiKey", apiKey: exports.ApiKeyAuth.fromJSON(object.apiKey) }
                    : isSet(object.api_key)
                        ? { $case: "apiKey", apiKey: exports.ApiKeyAuth.fromJSON(object.api_key) }
                        : isSet(object.oauth2)
                            ? { $case: "oauth2", oauth2: exports.OAuth2Auth.fromJSON(object.oauth2) }
                            : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.authType?.$case === "bearer") {
            obj.bearer = exports.BearerAuth.toJSON(message.authType.bearer);
        }
        else if (message.authType?.$case === "apiKey") {
            obj.apiKey = exports.ApiKeyAuth.toJSON(message.authType.apiKey);
        }
        else if (message.authType?.$case === "oauth2") {
            obj.oauth2 = exports.OAuth2Auth.toJSON(message.authType.oauth2);
        }
        return obj;
    },
    create(base) {
        return exports.AgentAuth.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAgentAuth();
        switch (object.authType?.$case) {
            case "bearer": {
                if (object.authType?.bearer !== undefined && object.authType?.bearer !== null) {
                    message.authType = { $case: "bearer", bearer: exports.BearerAuth.fromPartial(object.authType.bearer) };
                }
                break;
            }
            case "apiKey": {
                if (object.authType?.apiKey !== undefined && object.authType?.apiKey !== null) {
                    message.authType = { $case: "apiKey", apiKey: exports.ApiKeyAuth.fromPartial(object.authType.apiKey) };
                }
                break;
            }
            case "oauth2": {
                if (object.authType?.oauth2 !== undefined && object.authType?.oauth2 !== null) {
                    message.authType = { $case: "oauth2", oauth2: exports.OAuth2Auth.fromPartial(object.authType.oauth2) };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseBearerAuth() {
    return { token: "" };
}
exports.BearerAuth = {
    fromJSON(object) {
        return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.token !== "") {
            obj.token = message.token;
        }
        return obj;
    },
    create(base) {
        return exports.BearerAuth.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBearerAuth();
        message.token = object.token ?? "";
        return message;
    },
};
function createBaseApiKeyAuth() {
    return { header: "", key: "" };
}
exports.ApiKeyAuth = {
    fromJSON(object) {
        return {
            header: isSet(object.header) ? globalThis.String(object.header) : "",
            key: isSet(object.key) ? globalThis.String(object.key) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.header !== "") {
            obj.header = message.header;
        }
        if (message.key !== "") {
            obj.key = message.key;
        }
        return obj;
    },
    create(base) {
        return exports.ApiKeyAuth.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseApiKeyAuth();
        message.header = object.header ?? "";
        message.key = object.key ?? "";
        return message;
    },
};
function createBaseOAuth2Auth() {
    return { tokenUrl: "", clientId: "", clientSecret: "", scopes: [] };
}
exports.OAuth2Auth = {
    fromJSON(object) {
        return {
            tokenUrl: isSet(object.tokenUrl)
                ? globalThis.String(object.tokenUrl)
                : isSet(object.token_url)
                    ? globalThis.String(object.token_url)
                    : "",
            clientId: isSet(object.clientId)
                ? globalThis.String(object.clientId)
                : isSet(object.client_id)
                    ? globalThis.String(object.client_id)
                    : "",
            clientSecret: isSet(object.clientSecret)
                ? globalThis.String(object.clientSecret)
                : isSet(object.client_secret)
                    ? globalThis.String(object.client_secret)
                    : "",
            scopes: globalThis.Array.isArray(object?.scopes)
                ? object.scopes.map((e) => globalThis.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tokenUrl !== "") {
            obj.tokenUrl = message.tokenUrl;
        }
        if (message.clientId !== "") {
            obj.clientId = message.clientId;
        }
        if (message.clientSecret !== "") {
            obj.clientSecret = message.clientSecret;
        }
        if (message.scopes?.length) {
            obj.scopes = message.scopes;
        }
        return obj;
    },
    create(base) {
        return exports.OAuth2Auth.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOAuth2Auth();
        message.tokenUrl = object.tokenUrl ?? "";
        message.clientId = object.clientId ?? "";
        message.clientSecret = object.clientSecret ?? "";
        message.scopes = object.scopes?.map((e) => e) || [];
        return message;
    },
};
function createBaseAgentSkill() {
    return { name: "", description: undefined, inputSchema: undefined, outputSchema: undefined, examples: [] };
}
exports.AgentSkill = {
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
            inputSchema: isSet(object.inputSchema)
                ? exports.SchemaRef.fromJSON(object.inputSchema)
                : isSet(object.input_schema)
                    ? exports.SchemaRef.fromJSON(object.input_schema)
                    : undefined,
            outputSchema: isSet(object.outputSchema)
                ? exports.SchemaRef.fromJSON(object.outputSchema)
                : isSet(object.output_schema)
                    ? exports.SchemaRef.fromJSON(object.output_schema)
                    : undefined,
            examples: globalThis.Array.isArray(object?.examples)
                ? object.examples.map((e) => exports.SkillExample.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.inputSchema !== undefined) {
            obj.inputSchema = exports.SchemaRef.toJSON(message.inputSchema);
        }
        if (message.outputSchema !== undefined) {
            obj.outputSchema = exports.SchemaRef.toJSON(message.outputSchema);
        }
        if (message.examples?.length) {
            obj.examples = message.examples.map((e) => exports.SkillExample.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.AgentSkill.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAgentSkill();
        message.name = object.name ?? "";
        message.description = object.description ?? undefined;
        message.inputSchema = (object.inputSchema !== undefined && object.inputSchema !== null)
            ? exports.SchemaRef.fromPartial(object.inputSchema)
            : undefined;
        message.outputSchema = (object.outputSchema !== undefined && object.outputSchema !== null)
            ? exports.SchemaRef.fromPartial(object.outputSchema)
            : undefined;
        message.examples = object.examples?.map((e) => exports.SkillExample.fromPartial(e)) || [];
        return message;
    },
};
function createBaseSchemaRef() {
    return { schema: undefined };
}
exports.SchemaRef = {
    fromJSON(object) {
        return {
            schema: isSet(object.ref)
                ? { $case: "ref", ref: globalThis.String(object.ref) }
                : isSet(object.inline)
                    ? { $case: "inline", inline: object.inline }
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.schema?.$case === "ref") {
            obj.ref = message.schema.ref;
        }
        else if (message.schema?.$case === "inline") {
            obj.inline = message.schema.inline;
        }
        return obj;
    },
    create(base) {
        return exports.SchemaRef.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSchemaRef();
        switch (object.schema?.$case) {
            case "ref": {
                if (object.schema?.ref !== undefined && object.schema?.ref !== null) {
                    message.schema = { $case: "ref", ref: object.schema.ref };
                }
                break;
            }
            case "inline": {
                if (object.schema?.inline !== undefined && object.schema?.inline !== null) {
                    message.schema = { $case: "inline", inline: object.schema.inline };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseSkillExample() {
    return { input: undefined, output: undefined, description: undefined };
}
exports.SkillExample = {
    fromJSON(object) {
        return {
            input: isSet(object?.input) ? object.input : undefined,
            output: isSet(object?.output) ? object.output : undefined,
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.input !== undefined) {
            obj.input = message.input;
        }
        if (message.output !== undefined) {
            obj.output = message.output;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return exports.SkillExample.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSkillExample();
        message.input = object.input ?? undefined;
        message.output = object.output ?? undefined;
        message.description = object.description ?? undefined;
        return message;
    },
};
function createBaseAgentDependency() {
    return { dependency: undefined };
}
exports.AgentDependency = {
    fromJSON(object) {
        return {
            dependency: isSet(object.tool)
                ? { $case: "tool", tool: globalThis.String(object.tool) }
                : isSet(object.agent)
                    ? { $case: "agent", agent: globalThis.String(object.agent) }
                    : isSet(object.server)
                        ? { $case: "server", server: exports.ServerDependency.fromJSON(object.server) }
                        : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.dependency?.$case === "tool") {
            obj.tool = message.dependency.tool;
        }
        else if (message.dependency?.$case === "agent") {
            obj.agent = message.dependency.agent;
        }
        else if (message.dependency?.$case === "server") {
            obj.server = exports.ServerDependency.toJSON(message.dependency.server);
        }
        return obj;
    },
    create(base) {
        return exports.AgentDependency.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAgentDependency();
        switch (object.dependency?.$case) {
            case "tool": {
                if (object.dependency?.tool !== undefined && object.dependency?.tool !== null) {
                    message.dependency = { $case: "tool", tool: object.dependency.tool };
                }
                break;
            }
            case "agent": {
                if (object.dependency?.agent !== undefined && object.dependency?.agent !== null) {
                    message.dependency = { $case: "agent", agent: object.dependency.agent };
                }
                break;
            }
            case "server": {
                if (object.dependency?.server !== undefined && object.dependency?.server !== null) {
                    message.dependency = { $case: "server", server: exports.ServerDependency.fromPartial(object.dependency.server) };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseServerDependency() {
    return { name: "", versionConstraint: undefined, tools: [] };
}
exports.ServerDependency = {
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            versionConstraint: isSet(object.versionConstraint)
                ? globalThis.String(object.versionConstraint)
                : isSet(object.version_constraint)
                    ? globalThis.String(object.version_constraint)
                    : undefined,
            tools: globalThis.Array.isArray(object?.tools)
                ? object.tools.map((e) => globalThis.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.versionConstraint !== undefined) {
            obj.versionConstraint = message.versionConstraint;
        }
        if (message.tools?.length) {
            obj.tools = message.tools;
        }
        return obj;
    },
    create(base) {
        return exports.ServerDependency.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseServerDependency();
        message.name = object.name ?? "";
        message.versionConstraint = object.versionConstraint ?? undefined;
        message.tools = object.tools?.map((e) => e) || [];
        return message;
    },
};
function createBaseToolDefinition() {
    return {
        name: "",
        description: undefined,
        implementation: undefined,
        inputSchema: undefined,
        outputTransform: undefined,
        version: undefined,
        metadata: {},
    };
}
exports.ToolDefinition = {
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : undefined,
            implementation: isSet(object.source)
                ? { $case: "source", source: exports.SourceTool.fromJSON(object.source) }
                : isSet(object.spec)
                    ? { $case: "spec", spec: exports.PatternSpec.fromJSON(object.spec) }
                    : undefined,
            inputSchema: isObject(object.inputSchema)
                ? object.inputSchema
                : isObject(object.input_schema)
                    ? object.input_schema
                    : undefined,
            outputTransform: isSet(object.outputTransform)
                ? exports.OutputTransform.fromJSON(object.outputTransform)
                : isSet(object.output_transform)
                    ? exports.OutputTransform.fromJSON(object.output_transform)
                    : undefined,
            version: isSet(object.version) ? globalThis.String(object.version) : undefined,
            metadata: isObject(object.metadata)
                ? globalThis.Object.entries(object.metadata).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.implementation?.$case === "source") {
            obj.source = exports.SourceTool.toJSON(message.implementation.source);
        }
        else if (message.implementation?.$case === "spec") {
            obj.spec = exports.PatternSpec.toJSON(message.implementation.spec);
        }
        if (message.inputSchema !== undefined) {
            obj.inputSchema = message.inputSchema;
        }
        if (message.outputTransform !== undefined) {
            obj.outputTransform = exports.OutputTransform.toJSON(message.outputTransform);
        }
        if (message.version !== undefined) {
            obj.version = message.version;
        }
        if (message.metadata) {
            const entries = globalThis.Object.entries(message.metadata);
            if (entries.length > 0) {
                obj.metadata = {};
                entries.forEach(([k, v]) => {
                    obj.metadata[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.ToolDefinition.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseToolDefinition();
        message.name = object.name ?? "";
        message.description = object.description ?? undefined;
        switch (object.implementation?.$case) {
            case "source": {
                if (object.implementation?.source !== undefined && object.implementation?.source !== null) {
                    message.implementation = { $case: "source", source: exports.SourceTool.fromPartial(object.implementation.source) };
                }
                break;
            }
            case "spec": {
                if (object.implementation?.spec !== undefined && object.implementation?.spec !== null) {
                    message.implementation = { $case: "spec", spec: exports.PatternSpec.fromPartial(object.implementation.spec) };
                }
                break;
            }
        }
        message.inputSchema = object.inputSchema ?? undefined;
        message.outputTransform = (object.outputTransform !== undefined && object.outputTransform !== null)
            ? exports.OutputTransform.fromPartial(object.outputTransform)
            : undefined;
        message.version = object.version ?? undefined;
        message.metadata = globalThis.Object.entries(object.metadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseToolDefinition_MetadataEntry() {
    return { key: "", value: undefined };
}
exports.ToolDefinition_MetadataEntry = {
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.ToolDefinition_MetadataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseToolDefinition_MetadataEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseSourceTool() {
    return { server: "", tool: "", defaults: {}, hideFields: [], serverVersion: undefined };
}
exports.SourceTool = {
    fromJSON(object) {
        return {
            server: isSet(object.server) ? globalThis.String(object.server) : "",
            tool: isSet(object.tool) ? globalThis.String(object.tool) : "",
            defaults: isObject(object.defaults)
                ? globalThis.Object.entries(object.defaults).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
            hideFields: globalThis.Array.isArray(object?.hideFields)
                ? object.hideFields.map((e) => globalThis.String(e))
                : globalThis.Array.isArray(object?.hide_fields)
                    ? object.hide_fields.map((e) => globalThis.String(e))
                    : [],
            serverVersion: isSet(object.serverVersion)
                ? globalThis.String(object.serverVersion)
                : isSet(object.server_version)
                    ? globalThis.String(object.server_version)
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.server !== "") {
            obj.server = message.server;
        }
        if (message.tool !== "") {
            obj.tool = message.tool;
        }
        if (message.defaults) {
            const entries = globalThis.Object.entries(message.defaults);
            if (entries.length > 0) {
                obj.defaults = {};
                entries.forEach(([k, v]) => {
                    obj.defaults[k] = v;
                });
            }
        }
        if (message.hideFields?.length) {
            obj.hideFields = message.hideFields;
        }
        if (message.serverVersion !== undefined) {
            obj.serverVersion = message.serverVersion;
        }
        return obj;
    },
    create(base) {
        return exports.SourceTool.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSourceTool();
        message.server = object.server ?? "";
        message.tool = object.tool ?? "";
        message.defaults = globalThis.Object.entries(object.defaults ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        message.hideFields = object.hideFields?.map((e) => e) || [];
        message.serverVersion = object.serverVersion ?? undefined;
        return message;
    },
};
function createBaseSourceTool_DefaultsEntry() {
    return { key: "", value: undefined };
}
exports.SourceTool_DefaultsEntry = {
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.SourceTool_DefaultsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSourceTool_DefaultsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBasePatternSpec() {
    return { pattern: undefined };
}
exports.PatternSpec = {
    fromJSON(object) {
        return {
            pattern: isSet(object.pipeline)
                ? { $case: "pipeline", pipeline: exports.PipelineSpec.fromJSON(object.pipeline) }
                : isSet(object.scatterGather)
                    ? { $case: "scatterGather", scatterGather: exports.ScatterGatherSpec.fromJSON(object.scatterGather) }
                    : isSet(object.scatter_gather)
                        ? { $case: "scatterGather", scatterGather: exports.ScatterGatherSpec.fromJSON(object.scatter_gather) }
                        : isSet(object.filter)
                            ? { $case: "filter", filter: exports.FilterSpec.fromJSON(object.filter) }
                            : isSet(object.schemaMap)
                                ? { $case: "schemaMap", schemaMap: exports.SchemaMapSpec.fromJSON(object.schemaMap) }
                                : isSet(object.schema_map)
                                    ? { $case: "schemaMap", schemaMap: exports.SchemaMapSpec.fromJSON(object.schema_map) }
                                    : isSet(object.mapEach)
                                        ? { $case: "mapEach", mapEach: exports.MapEachSpec.fromJSON(object.mapEach) }
                                        : isSet(object.map_each)
                                            ? { $case: "mapEach", mapEach: exports.MapEachSpec.fromJSON(object.map_each) }
                                            : isSet(object.retry)
                                                ? { $case: "retry", retry: exports.RetrySpec.fromJSON(object.retry) }
                                                : isSet(object.timeout)
                                                    ? { $case: "timeout", timeout: exports.TimeoutSpec.fromJSON(object.timeout) }
                                                    : isSet(object.cache)
                                                        ? { $case: "cache", cache: exports.CacheSpec.fromJSON(object.cache) }
                                                        : isSet(object.idempotent)
                                                            ? { $case: "idempotent", idempotent: exports.IdempotentSpec.fromJSON(object.idempotent) }
                                                            : isSet(object.circuitBreaker)
                                                                ? { $case: "circuitBreaker", circuitBreaker: exports.CircuitBreakerSpec.fromJSON(object.circuitBreaker) }
                                                                : isSet(object.circuit_breaker)
                                                                    ? { $case: "circuitBreaker", circuitBreaker: exports.CircuitBreakerSpec.fromJSON(object.circuit_breaker) }
                                                                    : isSet(object.deadLetter)
                                                                        ? { $case: "deadLetter", deadLetter: exports.DeadLetterSpec.fromJSON(object.deadLetter) }
                                                                        : isSet(object.dead_letter)
                                                                            ? { $case: "deadLetter", deadLetter: exports.DeadLetterSpec.fromJSON(object.dead_letter) }
                                                                            : isSet(object.saga)
                                                                                ? { $case: "saga", saga: exports.SagaSpec.fromJSON(object.saga) }
                                                                                : isSet(object.claimCheck)
                                                                                    ? { $case: "claimCheck", claimCheck: exports.ClaimCheckSpec.fromJSON(object.claimCheck) }
                                                                                    : isSet(object.claim_check)
                                                                                        ? { $case: "claimCheck", claimCheck: exports.ClaimCheckSpec.fromJSON(object.claim_check) }
                                                                                        : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pattern?.$case === "pipeline") {
            obj.pipeline = exports.PipelineSpec.toJSON(message.pattern.pipeline);
        }
        else if (message.pattern?.$case === "scatterGather") {
            obj.scatterGather = exports.ScatterGatherSpec.toJSON(message.pattern.scatterGather);
        }
        else if (message.pattern?.$case === "filter") {
            obj.filter = exports.FilterSpec.toJSON(message.pattern.filter);
        }
        else if (message.pattern?.$case === "schemaMap") {
            obj.schemaMap = exports.SchemaMapSpec.toJSON(message.pattern.schemaMap);
        }
        else if (message.pattern?.$case === "mapEach") {
            obj.mapEach = exports.MapEachSpec.toJSON(message.pattern.mapEach);
        }
        else if (message.pattern?.$case === "retry") {
            obj.retry = exports.RetrySpec.toJSON(message.pattern.retry);
        }
        else if (message.pattern?.$case === "timeout") {
            obj.timeout = exports.TimeoutSpec.toJSON(message.pattern.timeout);
        }
        else if (message.pattern?.$case === "cache") {
            obj.cache = exports.CacheSpec.toJSON(message.pattern.cache);
        }
        else if (message.pattern?.$case === "idempotent") {
            obj.idempotent = exports.IdempotentSpec.toJSON(message.pattern.idempotent);
        }
        else if (message.pattern?.$case === "circuitBreaker") {
            obj.circuitBreaker = exports.CircuitBreakerSpec.toJSON(message.pattern.circuitBreaker);
        }
        else if (message.pattern?.$case === "deadLetter") {
            obj.deadLetter = exports.DeadLetterSpec.toJSON(message.pattern.deadLetter);
        }
        else if (message.pattern?.$case === "saga") {
            obj.saga = exports.SagaSpec.toJSON(message.pattern.saga);
        }
        else if (message.pattern?.$case === "claimCheck") {
            obj.claimCheck = exports.ClaimCheckSpec.toJSON(message.pattern.claimCheck);
        }
        return obj;
    },
    create(base) {
        return exports.PatternSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePatternSpec();
        switch (object.pattern?.$case) {
            case "pipeline": {
                if (object.pattern?.pipeline !== undefined && object.pattern?.pipeline !== null) {
                    message.pattern = { $case: "pipeline", pipeline: exports.PipelineSpec.fromPartial(object.pattern.pipeline) };
                }
                break;
            }
            case "scatterGather": {
                if (object.pattern?.scatterGather !== undefined && object.pattern?.scatterGather !== null) {
                    message.pattern = {
                        $case: "scatterGather",
                        scatterGather: exports.ScatterGatherSpec.fromPartial(object.pattern.scatterGather),
                    };
                }
                break;
            }
            case "filter": {
                if (object.pattern?.filter !== undefined && object.pattern?.filter !== null) {
                    message.pattern = { $case: "filter", filter: exports.FilterSpec.fromPartial(object.pattern.filter) };
                }
                break;
            }
            case "schemaMap": {
                if (object.pattern?.schemaMap !== undefined && object.pattern?.schemaMap !== null) {
                    message.pattern = { $case: "schemaMap", schemaMap: exports.SchemaMapSpec.fromPartial(object.pattern.schemaMap) };
                }
                break;
            }
            case "mapEach": {
                if (object.pattern?.mapEach !== undefined && object.pattern?.mapEach !== null) {
                    message.pattern = { $case: "mapEach", mapEach: exports.MapEachSpec.fromPartial(object.pattern.mapEach) };
                }
                break;
            }
            case "retry": {
                if (object.pattern?.retry !== undefined && object.pattern?.retry !== null) {
                    message.pattern = { $case: "retry", retry: exports.RetrySpec.fromPartial(object.pattern.retry) };
                }
                break;
            }
            case "timeout": {
                if (object.pattern?.timeout !== undefined && object.pattern?.timeout !== null) {
                    message.pattern = { $case: "timeout", timeout: exports.TimeoutSpec.fromPartial(object.pattern.timeout) };
                }
                break;
            }
            case "cache": {
                if (object.pattern?.cache !== undefined && object.pattern?.cache !== null) {
                    message.pattern = { $case: "cache", cache: exports.CacheSpec.fromPartial(object.pattern.cache) };
                }
                break;
            }
            case "idempotent": {
                if (object.pattern?.idempotent !== undefined && object.pattern?.idempotent !== null) {
                    message.pattern = { $case: "idempotent", idempotent: exports.IdempotentSpec.fromPartial(object.pattern.idempotent) };
                }
                break;
            }
            case "circuitBreaker": {
                if (object.pattern?.circuitBreaker !== undefined && object.pattern?.circuitBreaker !== null) {
                    message.pattern = {
                        $case: "circuitBreaker",
                        circuitBreaker: exports.CircuitBreakerSpec.fromPartial(object.pattern.circuitBreaker),
                    };
                }
                break;
            }
            case "deadLetter": {
                if (object.pattern?.deadLetter !== undefined && object.pattern?.deadLetter !== null) {
                    message.pattern = { $case: "deadLetter", deadLetter: exports.DeadLetterSpec.fromPartial(object.pattern.deadLetter) };
                }
                break;
            }
            case "saga": {
                if (object.pattern?.saga !== undefined && object.pattern?.saga !== null) {
                    message.pattern = { $case: "saga", saga: exports.SagaSpec.fromPartial(object.pattern.saga) };
                }
                break;
            }
            case "claimCheck": {
                if (object.pattern?.claimCheck !== undefined && object.pattern?.claimCheck !== null) {
                    message.pattern = { $case: "claimCheck", claimCheck: exports.ClaimCheckSpec.fromPartial(object.pattern.claimCheck) };
                }
                break;
            }
        }
        return message;
    },
};
function createBasePipelineSpec() {
    return { steps: [] };
}
exports.PipelineSpec = {
    fromJSON(object) {
        return {
            steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e) => exports.PipelineStep.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.steps?.length) {
            obj.steps = message.steps.map((e) => exports.PipelineStep.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.PipelineSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePipelineSpec();
        message.steps = object.steps?.map((e) => exports.PipelineStep.fromPartial(e)) || [];
        return message;
    },
};
function createBasePipelineStep() {
    return { id: "", operation: undefined, input: undefined };
}
exports.PipelineStep = {
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            operation: isSet(object.operation) ? exports.StepOperation.fromJSON(object.operation) : undefined,
            input: isSet(object.input) ? exports.DataBinding.fromJSON(object.input) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.operation !== undefined) {
            obj.operation = exports.StepOperation.toJSON(message.operation);
        }
        if (message.input !== undefined) {
            obj.input = exports.DataBinding.toJSON(message.input);
        }
        return obj;
    },
    create(base) {
        return exports.PipelineStep.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePipelineStep();
        message.id = object.id ?? "";
        message.operation = (object.operation !== undefined && object.operation !== null)
            ? exports.StepOperation.fromPartial(object.operation)
            : undefined;
        message.input = (object.input !== undefined && object.input !== null)
            ? exports.DataBinding.fromPartial(object.input)
            : undefined;
        return message;
    },
};
function createBaseStepOperation() {
    return { op: undefined };
}
exports.StepOperation = {
    fromJSON(object) {
        return {
            op: isSet(object.tool)
                ? { $case: "tool", tool: exports.ToolCall.fromJSON(object.tool) }
                : isSet(object.pattern)
                    ? { $case: "pattern", pattern: exports.PatternSpec.fromJSON(object.pattern) }
                    : isSet(object.agent)
                        ? { $case: "agent", agent: exports.AgentCall.fromJSON(object.agent) }
                        : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.op?.$case === "tool") {
            obj.tool = exports.ToolCall.toJSON(message.op.tool);
        }
        else if (message.op?.$case === "pattern") {
            obj.pattern = exports.PatternSpec.toJSON(message.op.pattern);
        }
        else if (message.op?.$case === "agent") {
            obj.agent = exports.AgentCall.toJSON(message.op.agent);
        }
        return obj;
    },
    create(base) {
        return exports.StepOperation.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStepOperation();
        switch (object.op?.$case) {
            case "tool": {
                if (object.op?.tool !== undefined && object.op?.tool !== null) {
                    message.op = { $case: "tool", tool: exports.ToolCall.fromPartial(object.op.tool) };
                }
                break;
            }
            case "pattern": {
                if (object.op?.pattern !== undefined && object.op?.pattern !== null) {
                    message.op = { $case: "pattern", pattern: exports.PatternSpec.fromPartial(object.op.pattern) };
                }
                break;
            }
            case "agent": {
                if (object.op?.agent !== undefined && object.op?.agent !== null) {
                    message.op = { $case: "agent", agent: exports.AgentCall.fromPartial(object.op.agent) };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseAgentCall() {
    return { name: "", skill: undefined, version: undefined };
}
exports.AgentCall = {
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            skill: isSet(object.skill) ? globalThis.String(object.skill) : undefined,
            version: isSet(object.version) ? globalThis.String(object.version) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.skill !== undefined) {
            obj.skill = message.skill;
        }
        if (message.version !== undefined) {
            obj.version = message.version;
        }
        return obj;
    },
    create(base) {
        return exports.AgentCall.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAgentCall();
        message.name = object.name ?? "";
        message.skill = object.skill ?? undefined;
        message.version = object.version ?? undefined;
        return message;
    },
};
function createBaseToolCall() {
    return { name: "", server: undefined, serverVersion: undefined };
}
exports.ToolCall = {
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            server: isSet(object.server) ? globalThis.String(object.server) : undefined,
            serverVersion: isSet(object.serverVersion)
                ? globalThis.String(object.serverVersion)
                : isSet(object.server_version)
                    ? globalThis.String(object.server_version)
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.server !== undefined) {
            obj.server = message.server;
        }
        if (message.serverVersion !== undefined) {
            obj.serverVersion = message.serverVersion;
        }
        return obj;
    },
    create(base) {
        return exports.ToolCall.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseToolCall();
        message.name = object.name ?? "";
        message.server = object.server ?? undefined;
        message.serverVersion = object.serverVersion ?? undefined;
        return message;
    },
};
function createBaseDataBinding() {
    return { source: undefined };
}
exports.DataBinding = {
    fromJSON(object) {
        return {
            source: isSet(object.input)
                ? { $case: "input", input: exports.InputBinding.fromJSON(object.input) }
                : isSet(object.step)
                    ? { $case: "step", step: exports.StepBinding.fromJSON(object.step) }
                    : isSet(object.constant)
                        ? { $case: "constant", constant: object.constant }
                        : isSet(object.construct)
                            ? { $case: "construct", construct: exports.ConstructBinding.fromJSON(object.construct) }
                            : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.source?.$case === "input") {
            obj.input = exports.InputBinding.toJSON(message.source.input);
        }
        else if (message.source?.$case === "step") {
            obj.step = exports.StepBinding.toJSON(message.source.step);
        }
        else if (message.source?.$case === "constant") {
            obj.constant = message.source.constant;
        }
        else if (message.source?.$case === "construct") {
            obj.construct = exports.ConstructBinding.toJSON(message.source.construct);
        }
        return obj;
    },
    create(base) {
        return exports.DataBinding.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDataBinding();
        switch (object.source?.$case) {
            case "input": {
                if (object.source?.input !== undefined && object.source?.input !== null) {
                    message.source = { $case: "input", input: exports.InputBinding.fromPartial(object.source.input) };
                }
                break;
            }
            case "step": {
                if (object.source?.step !== undefined && object.source?.step !== null) {
                    message.source = { $case: "step", step: exports.StepBinding.fromPartial(object.source.step) };
                }
                break;
            }
            case "constant": {
                if (object.source?.constant !== undefined && object.source?.constant !== null) {
                    message.source = { $case: "constant", constant: object.source.constant };
                }
                break;
            }
            case "construct": {
                if (object.source?.construct !== undefined && object.source?.construct !== null) {
                    message.source = { $case: "construct", construct: exports.ConstructBinding.fromPartial(object.source.construct) };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseInputBinding() {
    return { path: "" };
}
exports.InputBinding = {
    fromJSON(object) {
        return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.path !== "") {
            obj.path = message.path;
        }
        return obj;
    },
    create(base) {
        return exports.InputBinding.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInputBinding();
        message.path = object.path ?? "";
        return message;
    },
};
function createBaseStepBinding() {
    return { stepId: "", path: "" };
}
exports.StepBinding = {
    fromJSON(object) {
        return {
            stepId: isSet(object.stepId)
                ? globalThis.String(object.stepId)
                : isSet(object.step_id)
                    ? globalThis.String(object.step_id)
                    : "",
            path: isSet(object.path) ? globalThis.String(object.path) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.stepId !== "") {
            obj.stepId = message.stepId;
        }
        if (message.path !== "") {
            obj.path = message.path;
        }
        return obj;
    },
    create(base) {
        return exports.StepBinding.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStepBinding();
        message.stepId = object.stepId ?? "";
        message.path = object.path ?? "";
        return message;
    },
};
function createBaseConstructBinding() {
    return { fields: {} };
}
exports.ConstructBinding = {
    fromJSON(object) {
        return {
            fields: isObject(object.fields)
                ? globalThis.Object.entries(object.fields).reduce((acc, [key, value]) => {
                    acc[key] = exports.DataBinding.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.fields) {
            const entries = globalThis.Object.entries(message.fields);
            if (entries.length > 0) {
                obj.fields = {};
                entries.forEach(([k, v]) => {
                    obj.fields[k] = exports.DataBinding.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.ConstructBinding.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConstructBinding();
        message.fields = globalThis.Object.entries(object.fields ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.DataBinding.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseConstructBinding_FieldsEntry() {
    return { key: "", value: undefined };
}
exports.ConstructBinding_FieldsEntry = {
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? exports.DataBinding.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = exports.DataBinding.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.ConstructBinding_FieldsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConstructBinding_FieldsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.DataBinding.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseScatterGatherSpec() {
    return { targets: [], aggregation: undefined, timeoutMs: undefined, failFast: false };
}
exports.ScatterGatherSpec = {
    fromJSON(object) {
        return {
            targets: globalThis.Array.isArray(object?.targets)
                ? object.targets.map((e) => exports.ScatterTarget.fromJSON(e))
                : [],
            aggregation: isSet(object.aggregation) ? exports.AggregationStrategy.fromJSON(object.aggregation) : undefined,
            timeoutMs: isSet(object.timeoutMs)
                ? globalThis.Number(object.timeoutMs)
                : isSet(object.timeout_ms)
                    ? globalThis.Number(object.timeout_ms)
                    : undefined,
            failFast: isSet(object.failFast)
                ? globalThis.Boolean(object.failFast)
                : isSet(object.fail_fast)
                    ? globalThis.Boolean(object.fail_fast)
                    : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.targets?.length) {
            obj.targets = message.targets.map((e) => exports.ScatterTarget.toJSON(e));
        }
        if (message.aggregation !== undefined) {
            obj.aggregation = exports.AggregationStrategy.toJSON(message.aggregation);
        }
        if (message.timeoutMs !== undefined) {
            obj.timeoutMs = Math.round(message.timeoutMs);
        }
        if (message.failFast !== false) {
            obj.failFast = message.failFast;
        }
        return obj;
    },
    create(base) {
        return exports.ScatterGatherSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseScatterGatherSpec();
        message.targets = object.targets?.map((e) => exports.ScatterTarget.fromPartial(e)) || [];
        message.aggregation = (object.aggregation !== undefined && object.aggregation !== null)
            ? exports.AggregationStrategy.fromPartial(object.aggregation)
            : undefined;
        message.timeoutMs = object.timeoutMs ?? undefined;
        message.failFast = object.failFast ?? false;
        return message;
    },
};
function createBaseScatterTarget() {
    return { target: undefined };
}
exports.ScatterTarget = {
    fromJSON(object) {
        return {
            target: isSet(object.tool)
                ? { $case: "tool", tool: globalThis.String(object.tool) }
                : isSet(object.pattern)
                    ? { $case: "pattern", pattern: exports.PatternSpec.fromJSON(object.pattern) }
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.target?.$case === "tool") {
            obj.tool = message.target.tool;
        }
        else if (message.target?.$case === "pattern") {
            obj.pattern = exports.PatternSpec.toJSON(message.target.pattern);
        }
        return obj;
    },
    create(base) {
        return exports.ScatterTarget.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseScatterTarget();
        switch (object.target?.$case) {
            case "tool": {
                if (object.target?.tool !== undefined && object.target?.tool !== null) {
                    message.target = { $case: "tool", tool: object.target.tool };
                }
                break;
            }
            case "pattern": {
                if (object.target?.pattern !== undefined && object.target?.pattern !== null) {
                    message.target = { $case: "pattern", pattern: exports.PatternSpec.fromPartial(object.target.pattern) };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseAggregationStrategy() {
    return { ops: [] };
}
exports.AggregationStrategy = {
    fromJSON(object) {
        return { ops: globalThis.Array.isArray(object?.ops) ? object.ops.map((e) => exports.AggregationOp.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.ops?.length) {
            obj.ops = message.ops.map((e) => exports.AggregationOp.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.AggregationStrategy.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAggregationStrategy();
        message.ops = object.ops?.map((e) => exports.AggregationOp.fromPartial(e)) || [];
        return message;
    },
};
function createBaseAggregationOp() {
    return { op: undefined };
}
exports.AggregationOp = {
    fromJSON(object) {
        return {
            op: isSet(object.flatten)
                ? { $case: "flatten", flatten: globalThis.Boolean(object.flatten) }
                : isSet(object.sort)
                    ? { $case: "sort", sort: exports.SortOp.fromJSON(object.sort) }
                    : isSet(object.dedupe)
                        ? { $case: "dedupe", dedupe: exports.DedupeOp.fromJSON(object.dedupe) }
                        : isSet(object.limit)
                            ? { $case: "limit", limit: exports.LimitOp.fromJSON(object.limit) }
                            : isSet(object.concat)
                                ? { $case: "concat", concat: globalThis.Boolean(object.concat) }
                                : isSet(object.merge)
                                    ? { $case: "merge", merge: globalThis.Boolean(object.merge) }
                                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.op?.$case === "flatten") {
            obj.flatten = message.op.flatten;
        }
        else if (message.op?.$case === "sort") {
            obj.sort = exports.SortOp.toJSON(message.op.sort);
        }
        else if (message.op?.$case === "dedupe") {
            obj.dedupe = exports.DedupeOp.toJSON(message.op.dedupe);
        }
        else if (message.op?.$case === "limit") {
            obj.limit = exports.LimitOp.toJSON(message.op.limit);
        }
        else if (message.op?.$case === "concat") {
            obj.concat = message.op.concat;
        }
        else if (message.op?.$case === "merge") {
            obj.merge = message.op.merge;
        }
        return obj;
    },
    create(base) {
        return exports.AggregationOp.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAggregationOp();
        switch (object.op?.$case) {
            case "flatten": {
                if (object.op?.flatten !== undefined && object.op?.flatten !== null) {
                    message.op = { $case: "flatten", flatten: object.op.flatten };
                }
                break;
            }
            case "sort": {
                if (object.op?.sort !== undefined && object.op?.sort !== null) {
                    message.op = { $case: "sort", sort: exports.SortOp.fromPartial(object.op.sort) };
                }
                break;
            }
            case "dedupe": {
                if (object.op?.dedupe !== undefined && object.op?.dedupe !== null) {
                    message.op = { $case: "dedupe", dedupe: exports.DedupeOp.fromPartial(object.op.dedupe) };
                }
                break;
            }
            case "limit": {
                if (object.op?.limit !== undefined && object.op?.limit !== null) {
                    message.op = { $case: "limit", limit: exports.LimitOp.fromPartial(object.op.limit) };
                }
                break;
            }
            case "concat": {
                if (object.op?.concat !== undefined && object.op?.concat !== null) {
                    message.op = { $case: "concat", concat: object.op.concat };
                }
                break;
            }
            case "merge": {
                if (object.op?.merge !== undefined && object.op?.merge !== null) {
                    message.op = { $case: "merge", merge: object.op.merge };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseSortOp() {
    return { field: "", order: "" };
}
exports.SortOp = {
    fromJSON(object) {
        return {
            field: isSet(object.field) ? globalThis.String(object.field) : "",
            order: isSet(object.order) ? globalThis.String(object.order) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.field !== "") {
            obj.field = message.field;
        }
        if (message.order !== "") {
            obj.order = message.order;
        }
        return obj;
    },
    create(base) {
        return exports.SortOp.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSortOp();
        message.field = object.field ?? "";
        message.order = object.order ?? "";
        return message;
    },
};
function createBaseDedupeOp() {
    return { field: "" };
}
exports.DedupeOp = {
    fromJSON(object) {
        return { field: isSet(object.field) ? globalThis.String(object.field) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.field !== "") {
            obj.field = message.field;
        }
        return obj;
    },
    create(base) {
        return exports.DedupeOp.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDedupeOp();
        message.field = object.field ?? "";
        return message;
    },
};
function createBaseLimitOp() {
    return { count: 0 };
}
exports.LimitOp = {
    fromJSON(object) {
        return { count: isSet(object.count) ? globalThis.Number(object.count) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.count !== 0) {
            obj.count = Math.round(message.count);
        }
        return obj;
    },
    create(base) {
        return exports.LimitOp.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLimitOp();
        message.count = object.count ?? 0;
        return message;
    },
};
function createBaseFilterSpec() {
    return { predicate: undefined };
}
exports.FilterSpec = {
    fromJSON(object) {
        return { predicate: isSet(object.predicate) ? exports.FieldPredicate.fromJSON(object.predicate) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.predicate !== undefined) {
            obj.predicate = exports.FieldPredicate.toJSON(message.predicate);
        }
        return obj;
    },
    create(base) {
        return exports.FilterSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFilterSpec();
        message.predicate = (object.predicate !== undefined && object.predicate !== null)
            ? exports.FieldPredicate.fromPartial(object.predicate)
            : undefined;
        return message;
    },
};
function createBaseFieldPredicate() {
    return { field: "", op: "", value: undefined };
}
exports.FieldPredicate = {
    fromJSON(object) {
        return {
            field: isSet(object.field) ? globalThis.String(object.field) : "",
            op: isSet(object.op) ? globalThis.String(object.op) : "",
            value: isSet(object.value) ? exports.PredicateValue.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.field !== "") {
            obj.field = message.field;
        }
        if (message.op !== "") {
            obj.op = message.op;
        }
        if (message.value !== undefined) {
            obj.value = exports.PredicateValue.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.FieldPredicate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFieldPredicate();
        message.field = object.field ?? "";
        message.op = object.op ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.PredicateValue.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBasePredicateValue() {
    return { value: undefined };
}
exports.PredicateValue = {
    fromJSON(object) {
        return {
            value: isSet(object.stringValue)
                ? { $case: "stringValue", stringValue: globalThis.String(object.stringValue) }
                : isSet(object.string_value)
                    ? { $case: "stringValue", stringValue: globalThis.String(object.string_value) }
                    : isSet(object.numberValue)
                        ? { $case: "numberValue", numberValue: globalThis.Number(object.numberValue) }
                        : isSet(object.number_value)
                            ? { $case: "numberValue", numberValue: globalThis.Number(object.number_value) }
                            : isSet(object.boolValue)
                                ? { $case: "boolValue", boolValue: globalThis.Boolean(object.boolValue) }
                                : isSet(object.bool_value)
                                    ? { $case: "boolValue", boolValue: globalThis.Boolean(object.bool_value) }
                                    : isSet(object.nullValue)
                                        ? { $case: "nullValue", nullValue: globalThis.Boolean(object.nullValue) }
                                        : isSet(object.null_value)
                                            ? { $case: "nullValue", nullValue: globalThis.Boolean(object.null_value) }
                                            : isSet(object.listValue)
                                                ? { $case: "listValue", listValue: exports.ValueList.fromJSON(object.listValue) }
                                                : isSet(object.list_value)
                                                    ? { $case: "listValue", listValue: exports.ValueList.fromJSON(object.list_value) }
                                                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.value?.$case === "stringValue") {
            obj.stringValue = message.value.stringValue;
        }
        else if (message.value?.$case === "numberValue") {
            obj.numberValue = message.value.numberValue;
        }
        else if (message.value?.$case === "boolValue") {
            obj.boolValue = message.value.boolValue;
        }
        else if (message.value?.$case === "nullValue") {
            obj.nullValue = message.value.nullValue;
        }
        else if (message.value?.$case === "listValue") {
            obj.listValue = exports.ValueList.toJSON(message.value.listValue);
        }
        return obj;
    },
    create(base) {
        return exports.PredicateValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePredicateValue();
        switch (object.value?.$case) {
            case "stringValue": {
                if (object.value?.stringValue !== undefined && object.value?.stringValue !== null) {
                    message.value = { $case: "stringValue", stringValue: object.value.stringValue };
                }
                break;
            }
            case "numberValue": {
                if (object.value?.numberValue !== undefined && object.value?.numberValue !== null) {
                    message.value = { $case: "numberValue", numberValue: object.value.numberValue };
                }
                break;
            }
            case "boolValue": {
                if (object.value?.boolValue !== undefined && object.value?.boolValue !== null) {
                    message.value = { $case: "boolValue", boolValue: object.value.boolValue };
                }
                break;
            }
            case "nullValue": {
                if (object.value?.nullValue !== undefined && object.value?.nullValue !== null) {
                    message.value = { $case: "nullValue", nullValue: object.value.nullValue };
                }
                break;
            }
            case "listValue": {
                if (object.value?.listValue !== undefined && object.value?.listValue !== null) {
                    message.value = { $case: "listValue", listValue: exports.ValueList.fromPartial(object.value.listValue) };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseValueList() {
    return { values: [] };
}
exports.ValueList = {
    fromJSON(object) {
        return {
            values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => exports.PredicateValue.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.values?.length) {
            obj.values = message.values.map((e) => exports.PredicateValue.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.ValueList.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValueList();
        message.values = object.values?.map((e) => exports.PredicateValue.fromPartial(e)) || [];
        return message;
    },
};
function createBaseSchemaMapSpec() {
    return { mappings: {} };
}
exports.SchemaMapSpec = {
    fromJSON(object) {
        return {
            mappings: isObject(object.mappings)
                ? globalThis.Object.entries(object.mappings).reduce((acc, [key, value]) => {
                    acc[key] = exports.FieldSource.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.mappings) {
            const entries = globalThis.Object.entries(message.mappings);
            if (entries.length > 0) {
                obj.mappings = {};
                entries.forEach(([k, v]) => {
                    obj.mappings[k] = exports.FieldSource.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.SchemaMapSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSchemaMapSpec();
        message.mappings = globalThis.Object.entries(object.mappings ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.FieldSource.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseSchemaMapSpec_MappingsEntry() {
    return { key: "", value: undefined };
}
exports.SchemaMapSpec_MappingsEntry = {
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? exports.FieldSource.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = exports.FieldSource.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.SchemaMapSpec_MappingsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSchemaMapSpec_MappingsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.FieldSource.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseFieldSource() {
    return { source: undefined };
}
exports.FieldSource = {
    fromJSON(object) {
        return {
            source: isSet(object.path)
                ? { $case: "path", path: globalThis.String(object.path) }
                : isSet(object.literal)
                    ? { $case: "literal", literal: exports.LiteralValue.fromJSON(object.literal) }
                    : isSet(object.coalesce)
                        ? { $case: "coalesce", coalesce: exports.CoalesceSource.fromJSON(object.coalesce) }
                        : isSet(object.template)
                            ? { $case: "template", template: exports.TemplateSource.fromJSON(object.template) }
                            : isSet(object.concat)
                                ? { $case: "concat", concat: exports.ConcatSource.fromJSON(object.concat) }
                                : isSet(object.nested)
                                    ? { $case: "nested", nested: exports.SchemaMapSpec.fromJSON(object.nested) }
                                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.source?.$case === "path") {
            obj.path = message.source.path;
        }
        else if (message.source?.$case === "literal") {
            obj.literal = exports.LiteralValue.toJSON(message.source.literal);
        }
        else if (message.source?.$case === "coalesce") {
            obj.coalesce = exports.CoalesceSource.toJSON(message.source.coalesce);
        }
        else if (message.source?.$case === "template") {
            obj.template = exports.TemplateSource.toJSON(message.source.template);
        }
        else if (message.source?.$case === "concat") {
            obj.concat = exports.ConcatSource.toJSON(message.source.concat);
        }
        else if (message.source?.$case === "nested") {
            obj.nested = exports.SchemaMapSpec.toJSON(message.source.nested);
        }
        return obj;
    },
    create(base) {
        return exports.FieldSource.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFieldSource();
        switch (object.source?.$case) {
            case "path": {
                if (object.source?.path !== undefined && object.source?.path !== null) {
                    message.source = { $case: "path", path: object.source.path };
                }
                break;
            }
            case "literal": {
                if (object.source?.literal !== undefined && object.source?.literal !== null) {
                    message.source = { $case: "literal", literal: exports.LiteralValue.fromPartial(object.source.literal) };
                }
                break;
            }
            case "coalesce": {
                if (object.source?.coalesce !== undefined && object.source?.coalesce !== null) {
                    message.source = { $case: "coalesce", coalesce: exports.CoalesceSource.fromPartial(object.source.coalesce) };
                }
                break;
            }
            case "template": {
                if (object.source?.template !== undefined && object.source?.template !== null) {
                    message.source = { $case: "template", template: exports.TemplateSource.fromPartial(object.source.template) };
                }
                break;
            }
            case "concat": {
                if (object.source?.concat !== undefined && object.source?.concat !== null) {
                    message.source = { $case: "concat", concat: exports.ConcatSource.fromPartial(object.source.concat) };
                }
                break;
            }
            case "nested": {
                if (object.source?.nested !== undefined && object.source?.nested !== null) {
                    message.source = { $case: "nested", nested: exports.SchemaMapSpec.fromPartial(object.source.nested) };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseLiteralValue() {
    return { value: undefined };
}
exports.LiteralValue = {
    fromJSON(object) {
        return {
            value: isSet(object.stringValue)
                ? { $case: "stringValue", stringValue: globalThis.String(object.stringValue) }
                : isSet(object.string_value)
                    ? { $case: "stringValue", stringValue: globalThis.String(object.string_value) }
                    : isSet(object.numberValue)
                        ? { $case: "numberValue", numberValue: globalThis.Number(object.numberValue) }
                        : isSet(object.number_value)
                            ? { $case: "numberValue", numberValue: globalThis.Number(object.number_value) }
                            : isSet(object.boolValue)
                                ? { $case: "boolValue", boolValue: globalThis.Boolean(object.boolValue) }
                                : isSet(object.bool_value)
                                    ? { $case: "boolValue", boolValue: globalThis.Boolean(object.bool_value) }
                                    : isSet(object.nullValue)
                                        ? { $case: "nullValue", nullValue: globalThis.Boolean(object.nullValue) }
                                        : isSet(object.null_value)
                                            ? { $case: "nullValue", nullValue: globalThis.Boolean(object.null_value) }
                                            : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.value?.$case === "stringValue") {
            obj.stringValue = message.value.stringValue;
        }
        else if (message.value?.$case === "numberValue") {
            obj.numberValue = message.value.numberValue;
        }
        else if (message.value?.$case === "boolValue") {
            obj.boolValue = message.value.boolValue;
        }
        else if (message.value?.$case === "nullValue") {
            obj.nullValue = message.value.nullValue;
        }
        return obj;
    },
    create(base) {
        return exports.LiteralValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLiteralValue();
        switch (object.value?.$case) {
            case "stringValue": {
                if (object.value?.stringValue !== undefined && object.value?.stringValue !== null) {
                    message.value = { $case: "stringValue", stringValue: object.value.stringValue };
                }
                break;
            }
            case "numberValue": {
                if (object.value?.numberValue !== undefined && object.value?.numberValue !== null) {
                    message.value = { $case: "numberValue", numberValue: object.value.numberValue };
                }
                break;
            }
            case "boolValue": {
                if (object.value?.boolValue !== undefined && object.value?.boolValue !== null) {
                    message.value = { $case: "boolValue", boolValue: object.value.boolValue };
                }
                break;
            }
            case "nullValue": {
                if (object.value?.nullValue !== undefined && object.value?.nullValue !== null) {
                    message.value = { $case: "nullValue", nullValue: object.value.nullValue };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseCoalesceSource() {
    return { paths: [] };
}
exports.CoalesceSource = {
    fromJSON(object) {
        return { paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e) => globalThis.String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.paths?.length) {
            obj.paths = message.paths;
        }
        return obj;
    },
    create(base) {
        return exports.CoalesceSource.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCoalesceSource();
        message.paths = object.paths?.map((e) => e) || [];
        return message;
    },
};
function createBaseTemplateSource() {
    return { template: "", vars: {} };
}
exports.TemplateSource = {
    fromJSON(object) {
        return {
            template: isSet(object.template) ? globalThis.String(object.template) : "",
            vars: isObject(object.vars)
                ? globalThis.Object.entries(object.vars).reduce((acc, [key, value]) => {
                    acc[key] = globalThis.String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.template !== "") {
            obj.template = message.template;
        }
        if (message.vars) {
            const entries = globalThis.Object.entries(message.vars);
            if (entries.length > 0) {
                obj.vars = {};
                entries.forEach(([k, v]) => {
                    obj.vars[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.TemplateSource.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTemplateSource();
        message.template = object.template ?? "";
        message.vars = globalThis.Object.entries(object.vars ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseTemplateSource_VarsEntry() {
    return { key: "", value: "" };
}
exports.TemplateSource_VarsEntry = {
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.TemplateSource_VarsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTemplateSource_VarsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseConcatSource() {
    return { paths: [], separator: undefined };
}
exports.ConcatSource = {
    fromJSON(object) {
        return {
            paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e) => globalThis.String(e)) : [],
            separator: isSet(object.separator) ? globalThis.String(object.separator) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.paths?.length) {
            obj.paths = message.paths;
        }
        if (message.separator !== undefined) {
            obj.separator = message.separator;
        }
        return obj;
    },
    create(base) {
        return exports.ConcatSource.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConcatSource();
        message.paths = object.paths?.map((e) => e) || [];
        message.separator = object.separator ?? undefined;
        return message;
    },
};
function createBaseMapEachSpec() {
    return { inner: undefined };
}
exports.MapEachSpec = {
    fromJSON(object) {
        return { inner: isSet(object.inner) ? exports.MapEachInner.fromJSON(object.inner) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.inner !== undefined) {
            obj.inner = exports.MapEachInner.toJSON(message.inner);
        }
        return obj;
    },
    create(base) {
        return exports.MapEachSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMapEachSpec();
        message.inner = (object.inner !== undefined && object.inner !== null)
            ? exports.MapEachInner.fromPartial(object.inner)
            : undefined;
        return message;
    },
};
function createBaseMapEachInner() {
    return { inner: undefined };
}
exports.MapEachInner = {
    fromJSON(object) {
        return {
            inner: isSet(object.tool)
                ? { $case: "tool", tool: globalThis.String(object.tool) }
                : isSet(object.pattern)
                    ? { $case: "pattern", pattern: exports.PatternSpec.fromJSON(object.pattern) }
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.inner?.$case === "tool") {
            obj.tool = message.inner.tool;
        }
        else if (message.inner?.$case === "pattern") {
            obj.pattern = exports.PatternSpec.toJSON(message.inner.pattern);
        }
        return obj;
    },
    create(base) {
        return exports.MapEachInner.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMapEachInner();
        switch (object.inner?.$case) {
            case "tool": {
                if (object.inner?.tool !== undefined && object.inner?.tool !== null) {
                    message.inner = { $case: "tool", tool: object.inner.tool };
                }
                break;
            }
            case "pattern": {
                if (object.inner?.pattern !== undefined && object.inner?.pattern !== null) {
                    message.inner = { $case: "pattern", pattern: exports.PatternSpec.fromPartial(object.inner.pattern) };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseOutputTransform() {
    return { mappings: {} };
}
exports.OutputTransform = {
    fromJSON(object) {
        return {
            mappings: isObject(object.mappings)
                ? globalThis.Object.entries(object.mappings).reduce((acc, [key, value]) => {
                    acc[key] = exports.FieldSource.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.mappings) {
            const entries = globalThis.Object.entries(message.mappings);
            if (entries.length > 0) {
                obj.mappings = {};
                entries.forEach(([k, v]) => {
                    obj.mappings[k] = exports.FieldSource.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return exports.OutputTransform.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOutputTransform();
        message.mappings = globalThis.Object.entries(object.mappings ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.FieldSource.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseOutputTransform_MappingsEntry() {
    return { key: "", value: undefined };
}
exports.OutputTransform_MappingsEntry = {
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? exports.FieldSource.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = exports.FieldSource.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.OutputTransform_MappingsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOutputTransform_MappingsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.FieldSource.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseRetrySpec() {
    return {
        inner: undefined,
        maxAttempts: 0,
        backoff: undefined,
        retryIf: undefined,
        jitter: undefined,
        attemptTimeoutMs: undefined,
    };
}
exports.RetrySpec = {
    fromJSON(object) {
        return {
            inner: isSet(object.inner) ? exports.StepOperation.fromJSON(object.inner) : undefined,
            maxAttempts: isSet(object.maxAttempts)
                ? globalThis.Number(object.maxAttempts)
                : isSet(object.max_attempts)
                    ? globalThis.Number(object.max_attempts)
                    : 0,
            backoff: isSet(object.backoff) ? exports.BackoffStrategy.fromJSON(object.backoff) : undefined,
            retryIf: isSet(object.retryIf)
                ? exports.FieldPredicate.fromJSON(object.retryIf)
                : isSet(object.retry_if)
                    ? exports.FieldPredicate.fromJSON(object.retry_if)
                    : undefined,
            jitter: isSet(object.jitter) ? globalThis.Number(object.jitter) : undefined,
            attemptTimeoutMs: isSet(object.attemptTimeoutMs)
                ? globalThis.Number(object.attemptTimeoutMs)
                : isSet(object.attempt_timeout_ms)
                    ? globalThis.Number(object.attempt_timeout_ms)
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.inner !== undefined) {
            obj.inner = exports.StepOperation.toJSON(message.inner);
        }
        if (message.maxAttempts !== 0) {
            obj.maxAttempts = Math.round(message.maxAttempts);
        }
        if (message.backoff !== undefined) {
            obj.backoff = exports.BackoffStrategy.toJSON(message.backoff);
        }
        if (message.retryIf !== undefined) {
            obj.retryIf = exports.FieldPredicate.toJSON(message.retryIf);
        }
        if (message.jitter !== undefined) {
            obj.jitter = message.jitter;
        }
        if (message.attemptTimeoutMs !== undefined) {
            obj.attemptTimeoutMs = Math.round(message.attemptTimeoutMs);
        }
        return obj;
    },
    create(base) {
        return exports.RetrySpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRetrySpec();
        message.inner = (object.inner !== undefined && object.inner !== null)
            ? exports.StepOperation.fromPartial(object.inner)
            : undefined;
        message.maxAttempts = object.maxAttempts ?? 0;
        message.backoff = (object.backoff !== undefined && object.backoff !== null)
            ? exports.BackoffStrategy.fromPartial(object.backoff)
            : undefined;
        message.retryIf = (object.retryIf !== undefined && object.retryIf !== null)
            ? exports.FieldPredicate.fromPartial(object.retryIf)
            : undefined;
        message.jitter = object.jitter ?? undefined;
        message.attemptTimeoutMs = object.attemptTimeoutMs ?? undefined;
        return message;
    },
};
function createBaseBackoffStrategy() {
    return { strategy: undefined };
}
exports.BackoffStrategy = {
    fromJSON(object) {
        return {
            strategy: isSet(object.fixed)
                ? { $case: "fixed", fixed: exports.FixedBackoff.fromJSON(object.fixed) }
                : isSet(object.exponential)
                    ? { $case: "exponential", exponential: exports.ExponentialBackoff.fromJSON(object.exponential) }
                    : isSet(object.linear)
                        ? { $case: "linear", linear: exports.LinearBackoff.fromJSON(object.linear) }
                        : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.strategy?.$case === "fixed") {
            obj.fixed = exports.FixedBackoff.toJSON(message.strategy.fixed);
        }
        else if (message.strategy?.$case === "exponential") {
            obj.exponential = exports.ExponentialBackoff.toJSON(message.strategy.exponential);
        }
        else if (message.strategy?.$case === "linear") {
            obj.linear = exports.LinearBackoff.toJSON(message.strategy.linear);
        }
        return obj;
    },
    create(base) {
        return exports.BackoffStrategy.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBackoffStrategy();
        switch (object.strategy?.$case) {
            case "fixed": {
                if (object.strategy?.fixed !== undefined && object.strategy?.fixed !== null) {
                    message.strategy = { $case: "fixed", fixed: exports.FixedBackoff.fromPartial(object.strategy.fixed) };
                }
                break;
            }
            case "exponential": {
                if (object.strategy?.exponential !== undefined && object.strategy?.exponential !== null) {
                    message.strategy = {
                        $case: "exponential",
                        exponential: exports.ExponentialBackoff.fromPartial(object.strategy.exponential),
                    };
                }
                break;
            }
            case "linear": {
                if (object.strategy?.linear !== undefined && object.strategy?.linear !== null) {
                    message.strategy = { $case: "linear", linear: exports.LinearBackoff.fromPartial(object.strategy.linear) };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseFixedBackoff() {
    return { delayMs: 0 };
}
exports.FixedBackoff = {
    fromJSON(object) {
        return {
            delayMs: isSet(object.delayMs)
                ? globalThis.Number(object.delayMs)
                : isSet(object.delay_ms)
                    ? globalThis.Number(object.delay_ms)
                    : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delayMs !== 0) {
            obj.delayMs = Math.round(message.delayMs);
        }
        return obj;
    },
    create(base) {
        return exports.FixedBackoff.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFixedBackoff();
        message.delayMs = object.delayMs ?? 0;
        return message;
    },
};
function createBaseExponentialBackoff() {
    return { initialDelayMs: 0, maxDelayMs: 0, multiplier: undefined };
}
exports.ExponentialBackoff = {
    fromJSON(object) {
        return {
            initialDelayMs: isSet(object.initialDelayMs)
                ? globalThis.Number(object.initialDelayMs)
                : isSet(object.initial_delay_ms)
                    ? globalThis.Number(object.initial_delay_ms)
                    : 0,
            maxDelayMs: isSet(object.maxDelayMs)
                ? globalThis.Number(object.maxDelayMs)
                : isSet(object.max_delay_ms)
                    ? globalThis.Number(object.max_delay_ms)
                    : 0,
            multiplier: isSet(object.multiplier) ? globalThis.Number(object.multiplier) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.initialDelayMs !== 0) {
            obj.initialDelayMs = Math.round(message.initialDelayMs);
        }
        if (message.maxDelayMs !== 0) {
            obj.maxDelayMs = Math.round(message.maxDelayMs);
        }
        if (message.multiplier !== undefined) {
            obj.multiplier = message.multiplier;
        }
        return obj;
    },
    create(base) {
        return exports.ExponentialBackoff.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseExponentialBackoff();
        message.initialDelayMs = object.initialDelayMs ?? 0;
        message.maxDelayMs = object.maxDelayMs ?? 0;
        message.multiplier = object.multiplier ?? undefined;
        return message;
    },
};
function createBaseLinearBackoff() {
    return { initialDelayMs: 0, incrementMs: 0, maxDelayMs: 0 };
}
exports.LinearBackoff = {
    fromJSON(object) {
        return {
            initialDelayMs: isSet(object.initialDelayMs)
                ? globalThis.Number(object.initialDelayMs)
                : isSet(object.initial_delay_ms)
                    ? globalThis.Number(object.initial_delay_ms)
                    : 0,
            incrementMs: isSet(object.incrementMs)
                ? globalThis.Number(object.incrementMs)
                : isSet(object.increment_ms)
                    ? globalThis.Number(object.increment_ms)
                    : 0,
            maxDelayMs: isSet(object.maxDelayMs)
                ? globalThis.Number(object.maxDelayMs)
                : isSet(object.max_delay_ms)
                    ? globalThis.Number(object.max_delay_ms)
                    : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.initialDelayMs !== 0) {
            obj.initialDelayMs = Math.round(message.initialDelayMs);
        }
        if (message.incrementMs !== 0) {
            obj.incrementMs = Math.round(message.incrementMs);
        }
        if (message.maxDelayMs !== 0) {
            obj.maxDelayMs = Math.round(message.maxDelayMs);
        }
        return obj;
    },
    create(base) {
        return exports.LinearBackoff.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLinearBackoff();
        message.initialDelayMs = object.initialDelayMs ?? 0;
        message.incrementMs = object.incrementMs ?? 0;
        message.maxDelayMs = object.maxDelayMs ?? 0;
        return message;
    },
};
function createBaseTimeoutSpec() {
    return { inner: undefined, durationMs: 0, fallback: undefined, message: undefined };
}
exports.TimeoutSpec = {
    fromJSON(object) {
        return {
            inner: isSet(object.inner) ? exports.StepOperation.fromJSON(object.inner) : undefined,
            durationMs: isSet(object.durationMs)
                ? globalThis.Number(object.durationMs)
                : isSet(object.duration_ms)
                    ? globalThis.Number(object.duration_ms)
                    : 0,
            fallback: isSet(object.fallback) ? exports.StepOperation.fromJSON(object.fallback) : undefined,
            message: isSet(object.message) ? globalThis.String(object.message) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.inner !== undefined) {
            obj.inner = exports.StepOperation.toJSON(message.inner);
        }
        if (message.durationMs !== 0) {
            obj.durationMs = Math.round(message.durationMs);
        }
        if (message.fallback !== undefined) {
            obj.fallback = exports.StepOperation.toJSON(message.fallback);
        }
        if (message.message !== undefined) {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return exports.TimeoutSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTimeoutSpec();
        message.inner = (object.inner !== undefined && object.inner !== null)
            ? exports.StepOperation.fromPartial(object.inner)
            : undefined;
        message.durationMs = object.durationMs ?? 0;
        message.fallback = (object.fallback !== undefined && object.fallback !== null)
            ? exports.StepOperation.fromPartial(object.fallback)
            : undefined;
        message.message = object.message ?? undefined;
        return message;
    },
};
function createBaseCacheSpec() {
    return {
        keyPaths: [],
        inner: undefined,
        store: "",
        ttlSeconds: 0,
        staleWhileRevalidateSeconds: undefined,
        cacheIf: undefined,
    };
}
exports.CacheSpec = {
    fromJSON(object) {
        return {
            keyPaths: globalThis.Array.isArray(object?.keyPaths)
                ? object.keyPaths.map((e) => globalThis.String(e))
                : globalThis.Array.isArray(object?.key_paths)
                    ? object.key_paths.map((e) => globalThis.String(e))
                    : [],
            inner: isSet(object.inner) ? exports.StepOperation.fromJSON(object.inner) : undefined,
            store: isSet(object.store) ? globalThis.String(object.store) : "",
            ttlSeconds: isSet(object.ttlSeconds)
                ? globalThis.Number(object.ttlSeconds)
                : isSet(object.ttl_seconds)
                    ? globalThis.Number(object.ttl_seconds)
                    : 0,
            staleWhileRevalidateSeconds: isSet(object.staleWhileRevalidateSeconds)
                ? globalThis.Number(object.staleWhileRevalidateSeconds)
                : isSet(object.stale_while_revalidate_seconds)
                    ? globalThis.Number(object.stale_while_revalidate_seconds)
                    : undefined,
            cacheIf: isSet(object.cacheIf)
                ? exports.FieldPredicate.fromJSON(object.cacheIf)
                : isSet(object.cache_if)
                    ? exports.FieldPredicate.fromJSON(object.cache_if)
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.keyPaths?.length) {
            obj.keyPaths = message.keyPaths;
        }
        if (message.inner !== undefined) {
            obj.inner = exports.StepOperation.toJSON(message.inner);
        }
        if (message.store !== "") {
            obj.store = message.store;
        }
        if (message.ttlSeconds !== 0) {
            obj.ttlSeconds = Math.round(message.ttlSeconds);
        }
        if (message.staleWhileRevalidateSeconds !== undefined) {
            obj.staleWhileRevalidateSeconds = Math.round(message.staleWhileRevalidateSeconds);
        }
        if (message.cacheIf !== undefined) {
            obj.cacheIf = exports.FieldPredicate.toJSON(message.cacheIf);
        }
        return obj;
    },
    create(base) {
        return exports.CacheSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCacheSpec();
        message.keyPaths = object.keyPaths?.map((e) => e) || [];
        message.inner = (object.inner !== undefined && object.inner !== null)
            ? exports.StepOperation.fromPartial(object.inner)
            : undefined;
        message.store = object.store ?? "";
        message.ttlSeconds = object.ttlSeconds ?? 0;
        message.staleWhileRevalidateSeconds = object.staleWhileRevalidateSeconds ?? undefined;
        message.cacheIf = (object.cacheIf !== undefined && object.cacheIf !== null)
            ? exports.FieldPredicate.fromPartial(object.cacheIf)
            : undefined;
        return message;
    },
};
function createBaseIdempotentSpec() {
    return {
        keyPaths: [],
        inner: undefined,
        store: "",
        ttlSeconds: undefined,
        onDuplicate: OnDuplicate.ON_DUPLICATE_UNSPECIFIED,
    };
}
exports.IdempotentSpec = {
    fromJSON(object) {
        return {
            keyPaths: globalThis.Array.isArray(object?.keyPaths)
                ? object.keyPaths.map((e) => globalThis.String(e))
                : globalThis.Array.isArray(object?.key_paths)
                    ? object.key_paths.map((e) => globalThis.String(e))
                    : [],
            inner: isSet(object.inner) ? exports.StepOperation.fromJSON(object.inner) : undefined,
            store: isSet(object.store) ? globalThis.String(object.store) : "",
            ttlSeconds: isSet(object.ttlSeconds)
                ? globalThis.Number(object.ttlSeconds)
                : isSet(object.ttl_seconds)
                    ? globalThis.Number(object.ttl_seconds)
                    : undefined,
            onDuplicate: isSet(object.onDuplicate)
                ? onDuplicateFromJSON(object.onDuplicate)
                : isSet(object.on_duplicate)
                    ? onDuplicateFromJSON(object.on_duplicate)
                    : OnDuplicate.ON_DUPLICATE_UNSPECIFIED,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.keyPaths?.length) {
            obj.keyPaths = message.keyPaths;
        }
        if (message.inner !== undefined) {
            obj.inner = exports.StepOperation.toJSON(message.inner);
        }
        if (message.store !== "") {
            obj.store = message.store;
        }
        if (message.ttlSeconds !== undefined) {
            obj.ttlSeconds = Math.round(message.ttlSeconds);
        }
        if (message.onDuplicate !== OnDuplicate.ON_DUPLICATE_UNSPECIFIED) {
            obj.onDuplicate = onDuplicateToJSON(message.onDuplicate);
        }
        return obj;
    },
    create(base) {
        return exports.IdempotentSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseIdempotentSpec();
        message.keyPaths = object.keyPaths?.map((e) => e) || [];
        message.inner = (object.inner !== undefined && object.inner !== null)
            ? exports.StepOperation.fromPartial(object.inner)
            : undefined;
        message.store = object.store ?? "";
        message.ttlSeconds = object.ttlSeconds ?? undefined;
        message.onDuplicate = object.onDuplicate ?? OnDuplicate.ON_DUPLICATE_UNSPECIFIED;
        return message;
    },
};
function createBaseCircuitBreakerSpec() {
    return {
        name: "",
        inner: undefined,
        store: "",
        failureThreshold: 0,
        failureWindowSeconds: 0,
        resetTimeoutSeconds: 0,
        successThreshold: undefined,
        fallback: undefined,
        failureIf: undefined,
    };
}
exports.CircuitBreakerSpec = {
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            inner: isSet(object.inner) ? exports.StepOperation.fromJSON(object.inner) : undefined,
            store: isSet(object.store) ? globalThis.String(object.store) : "",
            failureThreshold: isSet(object.failureThreshold)
                ? globalThis.Number(object.failureThreshold)
                : isSet(object.failure_threshold)
                    ? globalThis.Number(object.failure_threshold)
                    : 0,
            failureWindowSeconds: isSet(object.failureWindowSeconds)
                ? globalThis.Number(object.failureWindowSeconds)
                : isSet(object.failure_window_seconds)
                    ? globalThis.Number(object.failure_window_seconds)
                    : 0,
            resetTimeoutSeconds: isSet(object.resetTimeoutSeconds)
                ? globalThis.Number(object.resetTimeoutSeconds)
                : isSet(object.reset_timeout_seconds)
                    ? globalThis.Number(object.reset_timeout_seconds)
                    : 0,
            successThreshold: isSet(object.successThreshold)
                ? globalThis.Number(object.successThreshold)
                : isSet(object.success_threshold)
                    ? globalThis.Number(object.success_threshold)
                    : undefined,
            fallback: isSet(object.fallback) ? exports.StepOperation.fromJSON(object.fallback) : undefined,
            failureIf: isSet(object.failureIf)
                ? exports.FieldPredicate.fromJSON(object.failureIf)
                : isSet(object.failure_if)
                    ? exports.FieldPredicate.fromJSON(object.failure_if)
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.inner !== undefined) {
            obj.inner = exports.StepOperation.toJSON(message.inner);
        }
        if (message.store !== "") {
            obj.store = message.store;
        }
        if (message.failureThreshold !== 0) {
            obj.failureThreshold = Math.round(message.failureThreshold);
        }
        if (message.failureWindowSeconds !== 0) {
            obj.failureWindowSeconds = Math.round(message.failureWindowSeconds);
        }
        if (message.resetTimeoutSeconds !== 0) {
            obj.resetTimeoutSeconds = Math.round(message.resetTimeoutSeconds);
        }
        if (message.successThreshold !== undefined) {
            obj.successThreshold = Math.round(message.successThreshold);
        }
        if (message.fallback !== undefined) {
            obj.fallback = exports.StepOperation.toJSON(message.fallback);
        }
        if (message.failureIf !== undefined) {
            obj.failureIf = exports.FieldPredicate.toJSON(message.failureIf);
        }
        return obj;
    },
    create(base) {
        return exports.CircuitBreakerSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCircuitBreakerSpec();
        message.name = object.name ?? "";
        message.inner = (object.inner !== undefined && object.inner !== null)
            ? exports.StepOperation.fromPartial(object.inner)
            : undefined;
        message.store = object.store ?? "";
        message.failureThreshold = object.failureThreshold ?? 0;
        message.failureWindowSeconds = object.failureWindowSeconds ?? 0;
        message.resetTimeoutSeconds = object.resetTimeoutSeconds ?? 0;
        message.successThreshold = object.successThreshold ?? undefined;
        message.fallback = (object.fallback !== undefined && object.fallback !== null)
            ? exports.StepOperation.fromPartial(object.fallback)
            : undefined;
        message.failureIf = (object.failureIf !== undefined && object.failureIf !== null)
            ? exports.FieldPredicate.fromPartial(object.failureIf)
            : undefined;
        return message;
    },
};
function createBaseDeadLetterSpec() {
    return { inner: undefined, deadLetterTool: "", maxAttempts: undefined, backoff: undefined, rethrow: false };
}
exports.DeadLetterSpec = {
    fromJSON(object) {
        return {
            inner: isSet(object.inner) ? exports.StepOperation.fromJSON(object.inner) : undefined,
            deadLetterTool: isSet(object.deadLetterTool)
                ? globalThis.String(object.deadLetterTool)
                : isSet(object.dead_letter_tool)
                    ? globalThis.String(object.dead_letter_tool)
                    : "",
            maxAttempts: isSet(object.maxAttempts)
                ? globalThis.Number(object.maxAttempts)
                : isSet(object.max_attempts)
                    ? globalThis.Number(object.max_attempts)
                    : undefined,
            backoff: isSet(object.backoff) ? exports.BackoffStrategy.fromJSON(object.backoff) : undefined,
            rethrow: isSet(object.rethrow) ? globalThis.Boolean(object.rethrow) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.inner !== undefined) {
            obj.inner = exports.StepOperation.toJSON(message.inner);
        }
        if (message.deadLetterTool !== "") {
            obj.deadLetterTool = message.deadLetterTool;
        }
        if (message.maxAttempts !== undefined) {
            obj.maxAttempts = Math.round(message.maxAttempts);
        }
        if (message.backoff !== undefined) {
            obj.backoff = exports.BackoffStrategy.toJSON(message.backoff);
        }
        if (message.rethrow !== false) {
            obj.rethrow = message.rethrow;
        }
        return obj;
    },
    create(base) {
        return exports.DeadLetterSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeadLetterSpec();
        message.inner = (object.inner !== undefined && object.inner !== null)
            ? exports.StepOperation.fromPartial(object.inner)
            : undefined;
        message.deadLetterTool = object.deadLetterTool ?? "";
        message.maxAttempts = object.maxAttempts ?? undefined;
        message.backoff = (object.backoff !== undefined && object.backoff !== null)
            ? exports.BackoffStrategy.fromPartial(object.backoff)
            : undefined;
        message.rethrow = object.rethrow ?? false;
        return message;
    },
};
function createBaseSagaSpec() {
    return { steps: [], store: undefined, sagaIdPath: undefined, timeoutMs: undefined, output: undefined };
}
exports.SagaSpec = {
    fromJSON(object) {
        return {
            steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e) => exports.SagaStep.fromJSON(e)) : [],
            store: isSet(object.store) ? globalThis.String(object.store) : undefined,
            sagaIdPath: isSet(object.sagaIdPath)
                ? globalThis.String(object.sagaIdPath)
                : isSet(object.saga_id_path)
                    ? globalThis.String(object.saga_id_path)
                    : undefined,
            timeoutMs: isSet(object.timeoutMs)
                ? globalThis.Number(object.timeoutMs)
                : isSet(object.timeout_ms)
                    ? globalThis.Number(object.timeout_ms)
                    : undefined,
            output: isSet(object.output) ? exports.DataBinding.fromJSON(object.output) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.steps?.length) {
            obj.steps = message.steps.map((e) => exports.SagaStep.toJSON(e));
        }
        if (message.store !== undefined) {
            obj.store = message.store;
        }
        if (message.sagaIdPath !== undefined) {
            obj.sagaIdPath = message.sagaIdPath;
        }
        if (message.timeoutMs !== undefined) {
            obj.timeoutMs = Math.round(message.timeoutMs);
        }
        if (message.output !== undefined) {
            obj.output = exports.DataBinding.toJSON(message.output);
        }
        return obj;
    },
    create(base) {
        return exports.SagaSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSagaSpec();
        message.steps = object.steps?.map((e) => exports.SagaStep.fromPartial(e)) || [];
        message.store = object.store ?? undefined;
        message.sagaIdPath = object.sagaIdPath ?? undefined;
        message.timeoutMs = object.timeoutMs ?? undefined;
        message.output = (object.output !== undefined && object.output !== null)
            ? exports.DataBinding.fromPartial(object.output)
            : undefined;
        return message;
    },
};
function createBaseSagaStep() {
    return { id: "", name: "", action: undefined, compensate: undefined, input: undefined };
}
exports.SagaStep = {
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            action: isSet(object.action) ? exports.StepOperation.fromJSON(object.action) : undefined,
            compensate: isSet(object.compensate) ? exports.StepOperation.fromJSON(object.compensate) : undefined,
            input: isSet(object.input) ? exports.DataBinding.fromJSON(object.input) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.action !== undefined) {
            obj.action = exports.StepOperation.toJSON(message.action);
        }
        if (message.compensate !== undefined) {
            obj.compensate = exports.StepOperation.toJSON(message.compensate);
        }
        if (message.input !== undefined) {
            obj.input = exports.DataBinding.toJSON(message.input);
        }
        return obj;
    },
    create(base) {
        return exports.SagaStep.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSagaStep();
        message.id = object.id ?? "";
        message.name = object.name ?? "";
        message.action = (object.action !== undefined && object.action !== null)
            ? exports.StepOperation.fromPartial(object.action)
            : undefined;
        message.compensate = (object.compensate !== undefined && object.compensate !== null)
            ? exports.StepOperation.fromPartial(object.compensate)
            : undefined;
        message.input = (object.input !== undefined && object.input !== null)
            ? exports.DataBinding.fromPartial(object.input)
            : undefined;
        return message;
    },
};
function createBaseClaimCheckSpec() {
    return { storeTool: "", retrieveTool: "", inner: undefined, retrieveAtEnd: false };
}
exports.ClaimCheckSpec = {
    fromJSON(object) {
        return {
            storeTool: isSet(object.storeTool)
                ? globalThis.String(object.storeTool)
                : isSet(object.store_tool)
                    ? globalThis.String(object.store_tool)
                    : "",
            retrieveTool: isSet(object.retrieveTool)
                ? globalThis.String(object.retrieveTool)
                : isSet(object.retrieve_tool)
                    ? globalThis.String(object.retrieve_tool)
                    : "",
            inner: isSet(object.inner) ? exports.StepOperation.fromJSON(object.inner) : undefined,
            retrieveAtEnd: isSet(object.retrieveAtEnd)
                ? globalThis.Boolean(object.retrieveAtEnd)
                : isSet(object.retrieve_at_end)
                    ? globalThis.Boolean(object.retrieve_at_end)
                    : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.storeTool !== "") {
            obj.storeTool = message.storeTool;
        }
        if (message.retrieveTool !== "") {
            obj.retrieveTool = message.retrieveTool;
        }
        if (message.inner !== undefined) {
            obj.inner = exports.StepOperation.toJSON(message.inner);
        }
        if (message.retrieveAtEnd !== false) {
            obj.retrieveAtEnd = message.retrieveAtEnd;
        }
        return obj;
    },
    create(base) {
        return exports.ClaimCheckSpec.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClaimCheckSpec();
        message.storeTool = object.storeTool ?? "";
        message.retrieveTool = object.retrieveTool ?? "";
        message.inner = (object.inner !== undefined && object.inner !== null)
            ? exports.StepOperation.fromPartial(object.inner)
            : undefined;
        message.retrieveAtEnd = object.retrieveAtEnd ?? false;
        return message;
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=registry.js.map