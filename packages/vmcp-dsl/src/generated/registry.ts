// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: registry.proto

/* eslint-disable */

export const protobufPackage = "agentgateway.dev.registry";

export enum OnDuplicate {
  ON_DUPLICATE_UNSPECIFIED = "ON_DUPLICATE_UNSPECIFIED",
  /** ON_DUPLICATE_CACHED - Return cached result */
  ON_DUPLICATE_CACHED = "ON_DUPLICATE_CACHED",
  /** ON_DUPLICATE_SKIP - Return null/empty */
  ON_DUPLICATE_SKIP = "ON_DUPLICATE_SKIP",
  /** ON_DUPLICATE_ERROR - Return error */
  ON_DUPLICATE_ERROR = "ON_DUPLICATE_ERROR",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function onDuplicateFromJSON(object: any): OnDuplicate {
  switch (object) {
    case 0:
    case "ON_DUPLICATE_UNSPECIFIED":
      return OnDuplicate.ON_DUPLICATE_UNSPECIFIED;
    case 1:
    case "ON_DUPLICATE_CACHED":
      return OnDuplicate.ON_DUPLICATE_CACHED;
    case 2:
    case "ON_DUPLICATE_SKIP":
      return OnDuplicate.ON_DUPLICATE_SKIP;
    case 3:
    case "ON_DUPLICATE_ERROR":
      return OnDuplicate.ON_DUPLICATE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OnDuplicate.UNRECOGNIZED;
  }
}

export function onDuplicateToJSON(object: OnDuplicate): string {
  switch (object) {
    case OnDuplicate.ON_DUPLICATE_UNSPECIFIED:
      return "ON_DUPLICATE_UNSPECIFIED";
    case OnDuplicate.ON_DUPLICATE_CACHED:
      return "ON_DUPLICATE_CACHED";
    case OnDuplicate.ON_DUPLICATE_SKIP:
      return "ON_DUPLICATE_SKIP";
    case OnDuplicate.ON_DUPLICATE_ERROR:
      return "ON_DUPLICATE_ERROR";
    case OnDuplicate.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Registry is the root container for the v2 registry IR
 * Contains schemas, servers, agents, and tools for full registry definition
 */
export interface Registry {
  /** Schema version for compatibility checking (e.g., "2.0") */
  schemaVersion: string;
  /** List of tool definitions (virtual tools and compositions) */
  tools: ToolDefinition[];
  /**
   * Named JSON Schema definitions (v2)
   * Can be referenced by tools via "$ref": "#/schemas/<name>"
   */
  schemas: SchemaDefinition[];
  /**
   * MCP server definitions with versioning (v2)
   * Enables version-aware routing and validation
   */
  servers: ServerDefinition[];
  /**
   * Agent definitions for A2A routing (v2)
   * Enables agent multiplexing and agent-as-tool execution
   */
  agents: AgentDefinition[];
}

/**
 * SchemaDefinition represents a named, reusable JSON Schema
 * Tools can reference these via "$ref": "#/schemas/<name>"
 */
export interface SchemaDefinition {
  /** Unique schema name (used in $ref) */
  name: string;
  /** Optional description of this schema */
  description?:
    | string
    | undefined;
  /** The JSON Schema definition */
  schema?:
    | { [key: string]: any }
    | undefined;
  /** Semantic version of this schema */
  version?:
    | string
    | undefined;
  /** Optional metadata (owner, classification, deprecation info, etc.) */
  metadata: { [key: string]: any | undefined };
}

export interface SchemaDefinition_MetadataEntry {
  key: string;
  value?: any | undefined;
}

/**
 * ServerDefinition represents an MCP server with versioning
 * Enables version-aware routing: "server:version" key dispatch
 */
export interface ServerDefinition {
  /** Server name (e.g., "doc-service") */
  name: string;
  /** Server version (e.g., "1.2.0") - forms "name:version" routing key */
  version: string;
  /** Optional description of this server */
  description?:
    | string
    | undefined;
  /** Server capabilities (what protocols/features it supports) */
  capabilities?:
    | ServerCapabilities
    | undefined;
  /**
   * Tools provided by this server (for validation)
   * Maps tool name -> expected input/output schema refs
   */
  providedTools: ServerTool[];
  /** Optional metadata (owner, team, health endpoint, etc.) */
  metadata: { [key: string]: any | undefined };
}

export interface ServerDefinition_MetadataEntry {
  key: string;
  value?: any | undefined;
}

/** ServerCapabilities describes what an MCP server supports */
export interface ServerCapabilities {
  /** Supports MCP StreamableHTTP protocol */
  streamableHttp: boolean;
  /** Supports MCP stdio protocol */
  stdio: boolean;
  /** Supports SSE transport */
  sse: boolean;
  /** Supports tool invocation */
  tools: boolean;
  /** Supports prompts */
  prompts: boolean;
  /** Supports resources */
  resources: boolean;
  /** Supports sampling */
  sampling: boolean;
}

/** ServerTool represents a tool provided by a server (for validation) */
export interface ServerTool {
  /** Tool name as exposed by the server */
  name: string;
  /** Expected input schema reference (e.g., "#/schemas/WeatherInput") */
  inputSchemaRef?:
    | string
    | undefined;
  /** Expected output schema reference (e.g., "#/schemas/WeatherOutput") */
  outputSchemaRef?: string | undefined;
}

/**
 * AgentDefinition represents an agent for A2A routing
 * Enables agent multiplexing and agent-as-tool execution
 */
export interface AgentDefinition {
  /** Unique agent name */
  name: string;
  /** Agent version (semantic versioning) */
  version: string;
  /** Human-readable description */
  description?:
    | string
    | undefined;
  /** Agent endpoint configuration */
  endpoint?:
    | AgentEndpoint
    | undefined;
  /** Skills/capabilities this agent provides */
  skills: AgentSkill[];
  /** Dependencies this agent has on other tools/agents */
  dependencies: AgentDependency[];
  /** Optional metadata (owner, team, cost tier, etc.) */
  metadata: { [key: string]: any | undefined };
}

export interface AgentDefinition_MetadataEntry {
  key: string;
  value?: any | undefined;
}

/** AgentEndpoint describes how to connect to an agent */
export interface AgentEndpoint {
  transport?:
    | //
    /** A2A HTTP endpoint */
    { $case: "a2a"; a2a: A2AEndpoint }
    | //
    /** MCP endpoint (for MCP-native agents) */
    { $case: "mcp"; mcp: MCPEndpoint }
    | undefined;
}

/** A2AEndpoint for Agent-to-Agent protocol connections */
export interface A2AEndpoint {
  /** Base URL for A2A requests */
  url: string;
  /** Authentication configuration (optional) */
  auth?: AgentAuth | undefined;
}

/** MCPEndpoint for MCP-native agent connections */
export interface MCPEndpoint {
  /** Server name reference (from servers list) */
  server: string;
  /** Server version (optional, uses latest if not specified) */
  serverVersion?: string | undefined;
}

/** AgentAuth describes authentication for agent connections */
export interface AgentAuth {
  authType?:
    | //
    /** Bearer token authentication */
    { $case: "bearer"; bearer: BearerAuth }
    | //
    /** API key authentication */
    { $case: "apiKey"; apiKey: ApiKeyAuth }
    | //
    /** OAuth2 client credentials */
    { $case: "oauth2"; oauth2: OAuth2Auth }
    | undefined;
}

export interface BearerAuth {
  /** Token value (supports ${ENV_VAR} substitution) */
  token: string;
}

export interface ApiKeyAuth {
  /** Header name for the API key */
  header: string;
  /** API key value (supports ${ENV_VAR} substitution) */
  key: string;
}

export interface OAuth2Auth {
  /** Token endpoint URL */
  tokenUrl: string;
  /** Client ID (supports ${ENV_VAR} substitution) */
  clientId: string;
  /** Client secret (supports ${ENV_VAR} substitution) */
  clientSecret: string;
  /** Scopes to request */
  scopes: string[];
}

/**
 * AgentSkill describes a capability an agent provides
 * Used for capability-based routing and discovery
 */
export interface AgentSkill {
  /** Skill name (e.g., "code_review", "research", "data_analysis") */
  name: string;
  /** Skill description */
  description?:
    | string
    | undefined;
  /** Input schema for this skill (JSON Schema reference or inline) */
  inputSchema?:
    | SchemaRef
    | undefined;
  /** Output schema for this skill */
  outputSchema?:
    | SchemaRef
    | undefined;
  /** Example invocations (for LLM context) */
  examples: SkillExample[];
}

/** SchemaRef can be either a reference to a named schema or inline */
export interface SchemaRef {
  schema?:
    | //
    /** Reference to a named schema: "#/schemas/<name>" */
    { $case: "ref"; ref: string }
    | //
    /** Inline JSON Schema definition */
    { $case: "inline"; inline: { [key: string]: any } | undefined }
    | undefined;
}

/** SkillExample provides example invocations for a skill */
export interface SkillExample {
  /** Example input */
  input?:
    | any
    | undefined;
  /** Expected output */
  output?:
    | any
    | undefined;
  /** Description of this example */
  description?: string | undefined;
}

/**
 * AgentDependency declares what tools/agents an agent depends on
 * Used for dependency-scoped discovery (WP11)
 */
export interface AgentDependency {
  dependency?:
    | //
    /** Depends on a specific tool by name */
    { $case: "tool"; tool: string }
    | //
    /** Depends on another agent by name */
    { $case: "agent"; agent: string }
    | //
    /** Depends on tools from a specific server */
    { $case: "server"; server: ServerDependency }
    | undefined;
}

/** ServerDependency declares dependency on tools from a server */
export interface ServerDependency {
  /** Server name */
  name: string;
  /** Optional version constraint (semver range, e.g., ">=1.0.0 <2.0.0") */
  versionConstraint?:
    | string
    | undefined;
  /** Specific tools from this server (empty means all) */
  tools: string[];
}

/** ToolDefinition represents either a virtual tool (1:1 mapping) or a composition (N:1 orchestration) */
export interface ToolDefinition {
  /** Name exposed to agents (unique identifier) */
  name: string;
  /** Optional description (for source-based, can inherit from backend) */
  description?:
    | string
    | undefined;
  /** Tool implementation - either source-based or composition */
  implementation?:
    | //
    /** Virtual tool: adapts a single backend tool (1:1) */
    { $case: "source"; source: SourceTool }
    | //
    /** Composition: orchestrates multiple tools (N:1) */
    { $case: "spec"; spec: PatternSpec }
    | undefined;
  /** Input schema override (JSON Schema as struct) */
  inputSchema?:
    | { [key: string]: any }
    | undefined;
  /** Output transformation (applies to both virtual tools and compositions) */
  outputTransform?:
    | OutputTransform
    | undefined;
  /** Semantic version of this tool definition */
  version?:
    | string
    | undefined;
  /** Arbitrary metadata (owner, classification, etc.) */
  metadata: { [key: string]: any | undefined };
}

export interface ToolDefinition_MetadataEntry {
  key: string;
  value?: any | undefined;
}

/** SourceTool defines a 1:1 mapping to a backend tool */
export interface SourceTool {
  /**
   * Server name (v2: references ServerDefinition.name)
   * For v1 compatibility, this is the target name in YAML config
   */
  server: string;
  /** Original tool name on that server */
  tool: string;
  /** Fields to inject at call time (supports ${ENV_VAR} substitution) */
  defaults: { [key: string]: any | undefined };
  /** Fields to remove from schema (hidden from agents) */
  hideFields: string[];
  /**
   * Server version constraint (v2)
   * If specified, forms "server:version" routing key
   * Supports semver ranges (e.g., ">=1.0.0 <2.0.0") or exact versions
   */
  serverVersion?: string | undefined;
}

export interface SourceTool_DefaultsEntry {
  key: string;
  value?: any | undefined;
}

/** PatternSpec defines a composition pattern */
export interface PatternSpec {
  pattern?:
    | //
    /** Stateless patterns (implemented) */
    { $case: "pipeline"; pipeline: PipelineSpec }
    | { $case: "scatterGather"; scatterGather: ScatterGatherSpec }
    | { $case: "filter"; filter: FilterSpec }
    | { $case: "schemaMap"; schemaMap: SchemaMapSpec }
    | { $case: "mapEach"; mapEach: MapEachSpec }
    | //
    /** Stateful patterns (IR defined, runtime not yet implemented) */
    { $case: "retry"; retry: RetrySpec }
    | { $case: "timeout"; timeout: TimeoutSpec }
    | { $case: "cache"; cache: CacheSpec }
    | { $case: "idempotent"; idempotent: IdempotentSpec }
    | { $case: "circuitBreaker"; circuitBreaker: CircuitBreakerSpec }
    | { $case: "deadLetter"; deadLetter: DeadLetterSpec }
    | { $case: "saga"; saga: SagaSpec }
    | { $case: "claimCheck"; claimCheck: ClaimCheckSpec }
    | undefined;
}

/** PipelineSpec executes steps sequentially, passing output to next step */
export interface PipelineSpec {
  steps: PipelineStep[];
}

export interface PipelineStep {
  /** Unique identifier for this step (for data binding references) */
  id: string;
  /** The operation to execute */
  operation?:
    | StepOperation
    | undefined;
  /** Input binding for this step */
  input?: DataBinding | undefined;
}

/** StepOperation defines what a step does */
export interface StepOperation {
  op?:
    | //
    /** Call a tool by name (resolved from registry or backend) */
    { $case: "tool"; tool: ToolCall }
    | //
    /** Inline pattern (no separate name) */
    { $case: "pattern"; pattern: PatternSpec }
    | //
    /** Call an agent (v2: for agent-as-tool execution) */
    { $case: "agent"; agent: AgentCall }
    | undefined;
}

/** AgentCall invokes a registered agent as a step operation */
export interface AgentCall {
  /** Agent name (references AgentDefinition.name) */
  name: string;
  /** Specific skill to invoke (optional, uses default if not specified) */
  skill?:
    | string
    | undefined;
  /** Agent version constraint (optional, uses latest if not specified) */
  version?: string | undefined;
}

export interface ToolCall {
  /** Tool name (can be virtual tool, composition, or backend tool) */
  name: string;
  /**
   * Server name override (v2: for direct backend tool calls)
   * If specified, bypasses registry lookup and calls tool directly on server
   */
  server?:
    | string
    | undefined;
  /** Server version constraint (v2) */
  serverVersion?: string | undefined;
}

/** DataBinding specifies where step input comes from */
export interface DataBinding {
  source?:
    | //
    /** From composition input */
    { $case: "input"; input: InputBinding }
    | //
    /** From a previous step's output */
    { $case: "step"; step: StepBinding }
    | //
    /** Constant value */
    { $case: "constant"; constant: any | undefined }
    | //
    /** Construct an object from multiple bindings */
    { $case: "construct"; construct: ConstructBinding }
    | undefined;
}

export interface InputBinding {
  /** JSONPath into composition input (e.g., "$" for whole input, "$.query" for field) */
  path: string;
}

export interface StepBinding {
  /** ID of the step to reference */
  stepId: string;
  /** JSONPath into step output */
  path: string;
}

/**
 * ConstructBinding builds an object from multiple bindings
 * Enables symmetric input construction (like outputTransform does for outputs)
 */
export interface ConstructBinding {
  /** Field name -> binding that produces the field value */
  fields: { [key: string]: DataBinding };
}

export interface ConstructBinding_FieldsEntry {
  key: string;
  value?: DataBinding | undefined;
}

/** ScatterGatherSpec fans out to multiple targets in parallel and aggregates results */
export interface ScatterGatherSpec {
  /** Targets to invoke in parallel */
  targets: ScatterTarget[];
  /** How to aggregate results */
  aggregation?:
    | AggregationStrategy
    | undefined;
  /** Timeout in milliseconds (optional) */
  timeoutMs?:
    | number
    | undefined;
  /** If true, fail immediately on first error; if false, collect partial results */
  failFast: boolean;
}

export interface ScatterTarget {
  target?:
    | //
    /** Tool name (resolved from registry or backend) */
    { $case: "tool"; tool: string }
    | //
    /** Inline pattern */
    { $case: "pattern"; pattern: PatternSpec }
    | undefined;
}

/** AggregationStrategy defines how to combine scatter-gather results */
export interface AggregationStrategy {
  /** Sequence of operations applied in order */
  ops: AggregationOp[];
}

export interface AggregationOp {
  op?:
    | //
    /** Flatten array of arrays into single array */
    { $case: "flatten"; flatten: boolean }
    | //
    /** Sort by field */
    { $case: "sort"; sort: SortOp }
    | //
    /** Deduplicate by field */
    { $case: "dedupe"; dedupe: DedupeOp }
    | //
    /** Take first N results */
    { $case: "limit"; limit: LimitOp }
    | //
    /** Keep arrays nested (no flattening) */
    { $case: "concat"; concat: boolean }
    | //
    /** Merge objects (for object results) */
    { $case: "merge"; merge: boolean }
    | undefined;
}

export interface SortOp {
  /** JSONPath to the field to sort by */
  field: string;
  /** Sort order: "asc" or "desc" */
  order: string;
}

export interface DedupeOp {
  /** JSONPath to the field to dedupe by */
  field: string;
}

export interface LimitOp {
  /** Maximum number of results */
  count: number;
}

/** FilterSpec filters array elements based on a predicate */
export interface FilterSpec {
  /** The predicate to evaluate for each element */
  predicate?: FieldPredicate | undefined;
}

export interface FieldPredicate {
  /** JSONPath to the field to evaluate */
  field: string;
  /** Comparison operator: "eq", "ne", "gt", "gte", "lt", "lte", "contains", "in" */
  op: string;
  /** Value to compare against */
  value?: PredicateValue | undefined;
}

export interface PredicateValue {
  value?: { $case: "stringValue"; stringValue: string } | { $case: "numberValue"; numberValue: number } | {
    $case: "boolValue";
    boolValue: boolean;
  } | //
  /** If true, represents null */
  { $case: "nullValue"; nullValue: boolean } | //
  /** For "in" operator */
  { $case: "listValue"; listValue: ValueList } | undefined;
}

export interface ValueList {
  values: PredicateValue[];
}

/** SchemaMapSpec transforms input to output using field mappings */
export interface SchemaMapSpec {
  /** Field name -> source mapping */
  mappings: { [key: string]: FieldSource };
}

export interface SchemaMapSpec_MappingsEntry {
  key: string;
  value?: FieldSource | undefined;
}

export interface FieldSource {
  source?:
    | //
    /** JSONPath extraction from input */
    { $case: "path"; path: string }
    | //
    /** Constant value */
    { $case: "literal"; literal: LiteralValue }
    | //
    /** First non-null from multiple paths */
    { $case: "coalesce"; coalesce: CoalesceSource }
    | //
    /** String template with variable substitution */
    { $case: "template"; template: TemplateSource }
    | //
    /** Concatenate multiple fields */
    { $case: "concat"; concat: ConcatSource }
    | //
    /** Nested object mapping */
    { $case: "nested"; nested: SchemaMapSpec }
    | undefined;
}

export interface LiteralValue {
  value?: { $case: "stringValue"; stringValue: string } | { $case: "numberValue"; numberValue: number } | {
    $case: "boolValue";
    boolValue: boolean;
  } | //
  /** If true, value is null */
  { $case: "nullValue"; nullValue: boolean } | undefined;
}

export interface CoalesceSource {
  /** JSONPaths to try in order, returning first non-null */
  paths: string[];
}

export interface TemplateSource {
  /** Template string with {var} placeholders */
  template: string;
  /** Variable name -> JSONPath binding */
  vars: { [key: string]: string };
}

export interface TemplateSource_VarsEntry {
  key: string;
  value: string;
}

export interface ConcatSource {
  /** JSONPaths to concatenate */
  paths: string[];
  /** Separator between values (default: empty string) */
  separator?: string | undefined;
}

/** MapEachSpec applies an operation to each element of an array */
export interface MapEachSpec {
  /** The operation to apply to each element */
  inner?: MapEachInner | undefined;
}

export interface MapEachInner {
  inner?:
    | //
    /** Tool name to call for each element */
    { $case: "tool"; tool: string }
    | //
    /** Pattern to apply for each element */
    { $case: "pattern"; pattern: PatternSpec }
    | undefined;
}

/**
 * OutputTransform defines how to transform tool/composition output
 * This is the unified, enhanced version supporting all mapping features
 */
export interface OutputTransform {
  /** Field name -> source mapping */
  mappings: { [key: string]: FieldSource };
}

export interface OutputTransform_MappingsEntry {
  key: string;
  value?: FieldSource | undefined;
}

/** RetrySpec - retry with configurable backoff on failure */
export interface RetrySpec {
  /** The operation to retry */
  inner?:
    | StepOperation
    | undefined;
  /** Maximum attempts (including initial) */
  maxAttempts: number;
  /** Backoff strategy */
  backoff?:
    | BackoffStrategy
    | undefined;
  /** Condition to retry (if absent, retry all errors) */
  retryIf?:
    | FieldPredicate
    | undefined;
  /** Jitter factor (0.0 - 1.0) */
  jitter?:
    | number
    | undefined;
  /** Per-attempt timeout in milliseconds */
  attemptTimeoutMs?: number | undefined;
}

export interface BackoffStrategy {
  strategy?: { $case: "fixed"; fixed: FixedBackoff } | { $case: "exponential"; exponential: ExponentialBackoff } | {
    $case: "linear";
    linear: LinearBackoff;
  } | undefined;
}

export interface FixedBackoff {
  delayMs: number;
}

export interface ExponentialBackoff {
  initialDelayMs: number;
  maxDelayMs: number;
  /** Default: 2.0 */
  multiplier?: number | undefined;
}

export interface LinearBackoff {
  initialDelayMs: number;
  incrementMs: number;
  maxDelayMs: number;
}

/** TimeoutSpec - enforce maximum execution duration */
export interface TimeoutSpec {
  /** The operation to wrap */
  inner?:
    | StepOperation
    | undefined;
  /** Timeout duration in milliseconds */
  durationMs: number;
  /** Fallback on timeout (optional) */
  fallback?:
    | StepOperation
    | undefined;
  /** Custom error message */
  message?: string | undefined;
}

/** CacheSpec - read-through caching with TTL */
export interface CacheSpec {
  /** JSONPath expressions to derive cache key */
  keyPaths: string[];
  /** The operation to cache */
  inner?:
    | StepOperation
    | undefined;
  /** Store reference name (configured in gateway) */
  store: string;
  /** TTL in seconds */
  ttlSeconds: number;
  /** Stale-while-revalidate window in seconds */
  staleWhileRevalidateSeconds?:
    | number
    | undefined;
  /** Condition to cache result (if absent, always cache) */
  cacheIf?: FieldPredicate | undefined;
}

/** IdempotentSpec - prevent duplicate processing */
export interface IdempotentSpec {
  /** JSONPath expressions to derive idempotency key */
  keyPaths: string[];
  /** The operation to wrap */
  inner?:
    | StepOperation
    | undefined;
  /** Store reference name (configured in gateway) */
  store: string;
  /** TTL in seconds (0 = no expiry) */
  ttlSeconds?:
    | number
    | undefined;
  /** Behavior on duplicate */
  onDuplicate: OnDuplicate;
}

/** CircuitBreakerSpec - fail fast with automatic recovery */
export interface CircuitBreakerSpec {
  /** Unique name for this circuit (for state isolation) */
  name: string;
  /** The protected operation */
  inner?:
    | StepOperation
    | undefined;
  /** Store for circuit state */
  store: string;
  /** Number of failures to trip the circuit */
  failureThreshold: number;
  /** Window for counting failures (seconds) */
  failureWindowSeconds: number;
  /** Time to wait before half-open (seconds) */
  resetTimeoutSeconds: number;
  /** Successes needed in half-open to close (default: 1) */
  successThreshold?:
    | number
    | undefined;
  /** Fallback when circuit is open (optional) */
  fallback?:
    | StepOperation
    | undefined;
  /** Custom failure condition (if absent, any error) */
  failureIf?: FieldPredicate | undefined;
}

/** DeadLetterSpec - capture failures for later processing */
export interface DeadLetterSpec {
  /** The operation to wrap */
  inner?:
    | StepOperation
    | undefined;
  /** Tool to invoke on failure */
  deadLetterTool: string;
  /** Max attempts before dead-lettering (default: 1) */
  maxAttempts?:
    | number
    | undefined;
  /** Backoff between attempts */
  backoff?:
    | BackoffStrategy
    | undefined;
  /** Whether to rethrow after dead-lettering */
  rethrow: boolean;
}

/** SagaSpec - distributed transaction with compensation */
export interface SagaSpec {
  /** Ordered list of saga steps */
  steps: SagaStep[];
  /** Store for saga state (for recovery) */
  store?:
    | string
    | undefined;
  /** JSONPath to derive saga instance ID */
  sagaIdPath?:
    | string
    | undefined;
  /** Timeout for entire saga in milliseconds */
  timeoutMs?:
    | number
    | undefined;
  /** Output binding */
  output?: DataBinding | undefined;
}

export interface SagaStep {
  /** Step identifier */
  id: string;
  /** Human-readable name */
  name: string;
  /** The action to perform */
  action?:
    | StepOperation
    | undefined;
  /** Compensating action (optional) */
  compensate?:
    | StepOperation
    | undefined;
  /** Input binding for this step */
  input?: DataBinding | undefined;
}

/** ClaimCheckSpec - externalize large payloads */
export interface ClaimCheckSpec {
  /** Tool to store payload and return reference */
  storeTool: string;
  /** Tool to retrieve payload from reference */
  retrieveTool: string;
  /** Inner operation operating on reference */
  inner?:
    | StepOperation
    | undefined;
  /** Whether to retrieve original at end */
  retrieveAtEnd: boolean;
}

function createBaseRegistry(): Registry {
  return { schemaVersion: "", tools: [], schemas: [], servers: [], agents: [] };
}

export const Registry: MessageFns<Registry> = {
  fromJSON(object: any): Registry {
    return {
      schemaVersion: isSet(object.schemaVersion)
        ? globalThis.String(object.schemaVersion)
        : isSet(object.schema_version)
        ? globalThis.String(object.schema_version)
        : "",
      tools: globalThis.Array.isArray(object?.tools)
        ? object.tools.map((e: any) => ToolDefinition.fromJSON(e))
        : [],
      schemas: globalThis.Array.isArray(object?.schemas)
        ? object.schemas.map((e: any) => SchemaDefinition.fromJSON(e))
        : [],
      servers: globalThis.Array.isArray(object?.servers)
        ? object.servers.map((e: any) => ServerDefinition.fromJSON(e))
        : [],
      agents: globalThis.Array.isArray(object?.agents)
        ? object.agents.map((e: any) => AgentDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Registry): unknown {
    const obj: any = {};
    if (message.schemaVersion !== "") {
      obj.schemaVersion = message.schemaVersion;
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.schemas?.length) {
      obj.schemas = message.schemas.map((e) => SchemaDefinition.toJSON(e));
    }
    if (message.servers?.length) {
      obj.servers = message.servers.map((e) => ServerDefinition.toJSON(e));
    }
    if (message.agents?.length) {
      obj.agents = message.agents.map((e) => AgentDefinition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Registry>, I>>(base?: I): Registry {
    return Registry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Registry>, I>>(object: I): Registry {
    const message = createBaseRegistry();
    message.schemaVersion = object.schemaVersion ?? "";
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.schemas = object.schemas?.map((e) => SchemaDefinition.fromPartial(e)) || [];
    message.servers = object.servers?.map((e) => ServerDefinition.fromPartial(e)) || [];
    message.agents = object.agents?.map((e) => AgentDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSchemaDefinition(): SchemaDefinition {
  return { name: "", description: undefined, schema: undefined, version: undefined, metadata: {} };
}

export const SchemaDefinition: MessageFns<SchemaDefinition> = {
  fromJSON(object: any): SchemaDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      schema: isObject(object.schema) ? object.schema : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: any | undefined }, [key, value]: [string, any]) => {
            acc[key] = value as any | undefined;
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: SchemaDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.schema !== undefined) {
      obj.schema = message.schema;
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, any | undefined][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SchemaDefinition>, I>>(base?: I): SchemaDefinition {
    return SchemaDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SchemaDefinition>, I>>(object: I): SchemaDefinition {
    const message = createBaseSchemaDefinition();
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.schema = object.schema ?? undefined;
    message.version = object.version ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, any | undefined][]).reduce(
      (acc: { [key: string]: any | undefined }, [key, value]: [string, any | undefined]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSchemaDefinition_MetadataEntry(): SchemaDefinition_MetadataEntry {
  return { key: "", value: undefined };
}

export const SchemaDefinition_MetadataEntry: MessageFns<SchemaDefinition_MetadataEntry> = {
  fromJSON(object: any): SchemaDefinition_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: SchemaDefinition_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SchemaDefinition_MetadataEntry>, I>>(base?: I): SchemaDefinition_MetadataEntry {
    return SchemaDefinition_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SchemaDefinition_MetadataEntry>, I>>(
    object: I,
  ): SchemaDefinition_MetadataEntry {
    const message = createBaseSchemaDefinition_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseServerDefinition(): ServerDefinition {
  return { name: "", version: "", description: undefined, capabilities: undefined, providedTools: [], metadata: {} };
}

export const ServerDefinition: MessageFns<ServerDefinition> = {
  fromJSON(object: any): ServerDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      capabilities: isSet(object.capabilities) ? ServerCapabilities.fromJSON(object.capabilities) : undefined,
      providedTools: globalThis.Array.isArray(object?.providedTools)
        ? object.providedTools.map((e: any) => ServerTool.fromJSON(e))
        : globalThis.Array.isArray(object?.provided_tools)
        ? object.provided_tools.map((e: any) => ServerTool.fromJSON(e))
        : [],
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: any | undefined }, [key, value]: [string, any]) => {
            acc[key] = value as any | undefined;
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ServerDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.capabilities !== undefined) {
      obj.capabilities = ServerCapabilities.toJSON(message.capabilities);
    }
    if (message.providedTools?.length) {
      obj.providedTools = message.providedTools.map((e) => ServerTool.toJSON(e));
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, any | undefined][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerDefinition>, I>>(base?: I): ServerDefinition {
    return ServerDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerDefinition>, I>>(object: I): ServerDefinition {
    const message = createBaseServerDefinition();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.description = object.description ?? undefined;
    message.capabilities = (object.capabilities !== undefined && object.capabilities !== null)
      ? ServerCapabilities.fromPartial(object.capabilities)
      : undefined;
    message.providedTools = object.providedTools?.map((e) => ServerTool.fromPartial(e)) || [];
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, any | undefined][]).reduce(
      (acc: { [key: string]: any | undefined }, [key, value]: [string, any | undefined]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseServerDefinition_MetadataEntry(): ServerDefinition_MetadataEntry {
  return { key: "", value: undefined };
}

export const ServerDefinition_MetadataEntry: MessageFns<ServerDefinition_MetadataEntry> = {
  fromJSON(object: any): ServerDefinition_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: ServerDefinition_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerDefinition_MetadataEntry>, I>>(base?: I): ServerDefinition_MetadataEntry {
    return ServerDefinition_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerDefinition_MetadataEntry>, I>>(
    object: I,
  ): ServerDefinition_MetadataEntry {
    const message = createBaseServerDefinition_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseServerCapabilities(): ServerCapabilities {
  return {
    streamableHttp: false,
    stdio: false,
    sse: false,
    tools: false,
    prompts: false,
    resources: false,
    sampling: false,
  };
}

export const ServerCapabilities: MessageFns<ServerCapabilities> = {
  fromJSON(object: any): ServerCapabilities {
    return {
      streamableHttp: isSet(object.streamableHttp)
        ? globalThis.Boolean(object.streamableHttp)
        : isSet(object.streamable_http)
        ? globalThis.Boolean(object.streamable_http)
        : false,
      stdio: isSet(object.stdio) ? globalThis.Boolean(object.stdio) : false,
      sse: isSet(object.sse) ? globalThis.Boolean(object.sse) : false,
      tools: isSet(object.tools) ? globalThis.Boolean(object.tools) : false,
      prompts: isSet(object.prompts) ? globalThis.Boolean(object.prompts) : false,
      resources: isSet(object.resources) ? globalThis.Boolean(object.resources) : false,
      sampling: isSet(object.sampling) ? globalThis.Boolean(object.sampling) : false,
    };
  },

  toJSON(message: ServerCapabilities): unknown {
    const obj: any = {};
    if (message.streamableHttp !== false) {
      obj.streamableHttp = message.streamableHttp;
    }
    if (message.stdio !== false) {
      obj.stdio = message.stdio;
    }
    if (message.sse !== false) {
      obj.sse = message.sse;
    }
    if (message.tools !== false) {
      obj.tools = message.tools;
    }
    if (message.prompts !== false) {
      obj.prompts = message.prompts;
    }
    if (message.resources !== false) {
      obj.resources = message.resources;
    }
    if (message.sampling !== false) {
      obj.sampling = message.sampling;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerCapabilities>, I>>(base?: I): ServerCapabilities {
    return ServerCapabilities.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerCapabilities>, I>>(object: I): ServerCapabilities {
    const message = createBaseServerCapabilities();
    message.streamableHttp = object.streamableHttp ?? false;
    message.stdio = object.stdio ?? false;
    message.sse = object.sse ?? false;
    message.tools = object.tools ?? false;
    message.prompts = object.prompts ?? false;
    message.resources = object.resources ?? false;
    message.sampling = object.sampling ?? false;
    return message;
  },
};

function createBaseServerTool(): ServerTool {
  return { name: "", inputSchemaRef: undefined, outputSchemaRef: undefined };
}

export const ServerTool: MessageFns<ServerTool> = {
  fromJSON(object: any): ServerTool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      inputSchemaRef: isSet(object.inputSchemaRef)
        ? globalThis.String(object.inputSchemaRef)
        : isSet(object.input_schema_ref)
        ? globalThis.String(object.input_schema_ref)
        : undefined,
      outputSchemaRef: isSet(object.outputSchemaRef)
        ? globalThis.String(object.outputSchemaRef)
        : isSet(object.output_schema_ref)
        ? globalThis.String(object.output_schema_ref)
        : undefined,
    };
  },

  toJSON(message: ServerTool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.inputSchemaRef !== undefined) {
      obj.inputSchemaRef = message.inputSchemaRef;
    }
    if (message.outputSchemaRef !== undefined) {
      obj.outputSchemaRef = message.outputSchemaRef;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerTool>, I>>(base?: I): ServerTool {
    return ServerTool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerTool>, I>>(object: I): ServerTool {
    const message = createBaseServerTool();
    message.name = object.name ?? "";
    message.inputSchemaRef = object.inputSchemaRef ?? undefined;
    message.outputSchemaRef = object.outputSchemaRef ?? undefined;
    return message;
  },
};

function createBaseAgentDefinition(): AgentDefinition {
  return {
    name: "",
    version: "",
    description: undefined,
    endpoint: undefined,
    skills: [],
    dependencies: [],
    metadata: {},
  };
}

export const AgentDefinition: MessageFns<AgentDefinition> = {
  fromJSON(object: any): AgentDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      endpoint: isSet(object.endpoint) ? AgentEndpoint.fromJSON(object.endpoint) : undefined,
      skills: globalThis.Array.isArray(object?.skills) ? object.skills.map((e: any) => AgentSkill.fromJSON(e)) : [],
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => AgentDependency.fromJSON(e))
        : [],
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: any | undefined }, [key, value]: [string, any]) => {
            acc[key] = value as any | undefined;
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: AgentDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.endpoint !== undefined) {
      obj.endpoint = AgentEndpoint.toJSON(message.endpoint);
    }
    if (message.skills?.length) {
      obj.skills = message.skills.map((e) => AgentSkill.toJSON(e));
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies.map((e) => AgentDependency.toJSON(e));
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, any | undefined][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentDefinition>, I>>(base?: I): AgentDefinition {
    return AgentDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentDefinition>, I>>(object: I): AgentDefinition {
    const message = createBaseAgentDefinition();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.description = object.description ?? undefined;
    message.endpoint = (object.endpoint !== undefined && object.endpoint !== null)
      ? AgentEndpoint.fromPartial(object.endpoint)
      : undefined;
    message.skills = object.skills?.map((e) => AgentSkill.fromPartial(e)) || [];
    message.dependencies = object.dependencies?.map((e) => AgentDependency.fromPartial(e)) || [];
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, any | undefined][]).reduce(
      (acc: { [key: string]: any | undefined }, [key, value]: [string, any | undefined]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAgentDefinition_MetadataEntry(): AgentDefinition_MetadataEntry {
  return { key: "", value: undefined };
}

export const AgentDefinition_MetadataEntry: MessageFns<AgentDefinition_MetadataEntry> = {
  fromJSON(object: any): AgentDefinition_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: AgentDefinition_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentDefinition_MetadataEntry>, I>>(base?: I): AgentDefinition_MetadataEntry {
    return AgentDefinition_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentDefinition_MetadataEntry>, I>>(
    object: I,
  ): AgentDefinition_MetadataEntry {
    const message = createBaseAgentDefinition_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseAgentEndpoint(): AgentEndpoint {
  return { transport: undefined };
}

export const AgentEndpoint: MessageFns<AgentEndpoint> = {
  fromJSON(object: any): AgentEndpoint {
    return {
      transport: isSet(object.a2a)
        ? { $case: "a2a", a2a: A2AEndpoint.fromJSON(object.a2a) }
        : isSet(object.mcp)
        ? { $case: "mcp", mcp: MCPEndpoint.fromJSON(object.mcp) }
        : undefined,
    };
  },

  toJSON(message: AgentEndpoint): unknown {
    const obj: any = {};
    if (message.transport?.$case === "a2a") {
      obj.a2a = A2AEndpoint.toJSON(message.transport.a2a);
    } else if (message.transport?.$case === "mcp") {
      obj.mcp = MCPEndpoint.toJSON(message.transport.mcp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentEndpoint>, I>>(base?: I): AgentEndpoint {
    return AgentEndpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentEndpoint>, I>>(object: I): AgentEndpoint {
    const message = createBaseAgentEndpoint();
    switch (object.transport?.$case) {
      case "a2a": {
        if (object.transport?.a2a !== undefined && object.transport?.a2a !== null) {
          message.transport = { $case: "a2a", a2a: A2AEndpoint.fromPartial(object.transport.a2a) };
        }
        break;
      }
      case "mcp": {
        if (object.transport?.mcp !== undefined && object.transport?.mcp !== null) {
          message.transport = { $case: "mcp", mcp: MCPEndpoint.fromPartial(object.transport.mcp) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseA2AEndpoint(): A2AEndpoint {
  return { url: "", auth: undefined };
}

export const A2AEndpoint: MessageFns<A2AEndpoint> = {
  fromJSON(object: any): A2AEndpoint {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      auth: isSet(object.auth) ? AgentAuth.fromJSON(object.auth) : undefined,
    };
  },

  toJSON(message: A2AEndpoint): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.auth !== undefined) {
      obj.auth = AgentAuth.toJSON(message.auth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<A2AEndpoint>, I>>(base?: I): A2AEndpoint {
    return A2AEndpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<A2AEndpoint>, I>>(object: I): A2AEndpoint {
    const message = createBaseA2AEndpoint();
    message.url = object.url ?? "";
    message.auth = (object.auth !== undefined && object.auth !== null) ? AgentAuth.fromPartial(object.auth) : undefined;
    return message;
  },
};

function createBaseMCPEndpoint(): MCPEndpoint {
  return { server: "", serverVersion: undefined };
}

export const MCPEndpoint: MessageFns<MCPEndpoint> = {
  fromJSON(object: any): MCPEndpoint {
    return {
      server: isSet(object.server) ? globalThis.String(object.server) : "",
      serverVersion: isSet(object.serverVersion)
        ? globalThis.String(object.serverVersion)
        : isSet(object.server_version)
        ? globalThis.String(object.server_version)
        : undefined,
    };
  },

  toJSON(message: MCPEndpoint): unknown {
    const obj: any = {};
    if (message.server !== "") {
      obj.server = message.server;
    }
    if (message.serverVersion !== undefined) {
      obj.serverVersion = message.serverVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MCPEndpoint>, I>>(base?: I): MCPEndpoint {
    return MCPEndpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MCPEndpoint>, I>>(object: I): MCPEndpoint {
    const message = createBaseMCPEndpoint();
    message.server = object.server ?? "";
    message.serverVersion = object.serverVersion ?? undefined;
    return message;
  },
};

function createBaseAgentAuth(): AgentAuth {
  return { authType: undefined };
}

export const AgentAuth: MessageFns<AgentAuth> = {
  fromJSON(object: any): AgentAuth {
    return {
      authType: isSet(object.bearer)
        ? { $case: "bearer", bearer: BearerAuth.fromJSON(object.bearer) }
        : isSet(object.apiKey)
        ? { $case: "apiKey", apiKey: ApiKeyAuth.fromJSON(object.apiKey) }
        : isSet(object.api_key)
        ? { $case: "apiKey", apiKey: ApiKeyAuth.fromJSON(object.api_key) }
        : isSet(object.oauth2)
        ? { $case: "oauth2", oauth2: OAuth2Auth.fromJSON(object.oauth2) }
        : undefined,
    };
  },

  toJSON(message: AgentAuth): unknown {
    const obj: any = {};
    if (message.authType?.$case === "bearer") {
      obj.bearer = BearerAuth.toJSON(message.authType.bearer);
    } else if (message.authType?.$case === "apiKey") {
      obj.apiKey = ApiKeyAuth.toJSON(message.authType.apiKey);
    } else if (message.authType?.$case === "oauth2") {
      obj.oauth2 = OAuth2Auth.toJSON(message.authType.oauth2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentAuth>, I>>(base?: I): AgentAuth {
    return AgentAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentAuth>, I>>(object: I): AgentAuth {
    const message = createBaseAgentAuth();
    switch (object.authType?.$case) {
      case "bearer": {
        if (object.authType?.bearer !== undefined && object.authType?.bearer !== null) {
          message.authType = { $case: "bearer", bearer: BearerAuth.fromPartial(object.authType.bearer) };
        }
        break;
      }
      case "apiKey": {
        if (object.authType?.apiKey !== undefined && object.authType?.apiKey !== null) {
          message.authType = { $case: "apiKey", apiKey: ApiKeyAuth.fromPartial(object.authType.apiKey) };
        }
        break;
      }
      case "oauth2": {
        if (object.authType?.oauth2 !== undefined && object.authType?.oauth2 !== null) {
          message.authType = { $case: "oauth2", oauth2: OAuth2Auth.fromPartial(object.authType.oauth2) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseBearerAuth(): BearerAuth {
  return { token: "" };
}

export const BearerAuth: MessageFns<BearerAuth> = {
  fromJSON(object: any): BearerAuth {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: BearerAuth): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BearerAuth>, I>>(base?: I): BearerAuth {
    return BearerAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BearerAuth>, I>>(object: I): BearerAuth {
    const message = createBaseBearerAuth();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseApiKeyAuth(): ApiKeyAuth {
  return { header: "", key: "" };
}

export const ApiKeyAuth: MessageFns<ApiKeyAuth> = {
  fromJSON(object: any): ApiKeyAuth {
    return {
      header: isSet(object.header) ? globalThis.String(object.header) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: ApiKeyAuth): unknown {
    const obj: any = {};
    if (message.header !== "") {
      obj.header = message.header;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiKeyAuth>, I>>(base?: I): ApiKeyAuth {
    return ApiKeyAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiKeyAuth>, I>>(object: I): ApiKeyAuth {
    const message = createBaseApiKeyAuth();
    message.header = object.header ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseOAuth2Auth(): OAuth2Auth {
  return { tokenUrl: "", clientId: "", clientSecret: "", scopes: [] };
}

export const OAuth2Auth: MessageFns<OAuth2Auth> = {
  fromJSON(object: any): OAuth2Auth {
    return {
      tokenUrl: isSet(object.tokenUrl)
        ? globalThis.String(object.tokenUrl)
        : isSet(object.token_url)
        ? globalThis.String(object.token_url)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      clientSecret: isSet(object.clientSecret)
        ? globalThis.String(object.clientSecret)
        : isSet(object.client_secret)
        ? globalThis.String(object.client_secret)
        : "",
      scopes: globalThis.Array.isArray(object?.scopes)
        ? object.scopes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OAuth2Auth): unknown {
    const obj: any = {};
    if (message.tokenUrl !== "") {
      obj.tokenUrl = message.tokenUrl;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuth2Auth>, I>>(base?: I): OAuth2Auth {
    return OAuth2Auth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuth2Auth>, I>>(object: I): OAuth2Auth {
    const message = createBaseOAuth2Auth();
    message.tokenUrl = object.tokenUrl ?? "";
    message.clientId = object.clientId ?? "";
    message.clientSecret = object.clientSecret ?? "";
    message.scopes = object.scopes?.map((e) => e) || [];
    return message;
  },
};

function createBaseAgentSkill(): AgentSkill {
  return { name: "", description: undefined, inputSchema: undefined, outputSchema: undefined, examples: [] };
}

export const AgentSkill: MessageFns<AgentSkill> = {
  fromJSON(object: any): AgentSkill {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      inputSchema: isSet(object.inputSchema)
        ? SchemaRef.fromJSON(object.inputSchema)
        : isSet(object.input_schema)
        ? SchemaRef.fromJSON(object.input_schema)
        : undefined,
      outputSchema: isSet(object.outputSchema)
        ? SchemaRef.fromJSON(object.outputSchema)
        : isSet(object.output_schema)
        ? SchemaRef.fromJSON(object.output_schema)
        : undefined,
      examples: globalThis.Array.isArray(object?.examples)
        ? object.examples.map((e: any) => SkillExample.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgentSkill): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.inputSchema !== undefined) {
      obj.inputSchema = SchemaRef.toJSON(message.inputSchema);
    }
    if (message.outputSchema !== undefined) {
      obj.outputSchema = SchemaRef.toJSON(message.outputSchema);
    }
    if (message.examples?.length) {
      obj.examples = message.examples.map((e) => SkillExample.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentSkill>, I>>(base?: I): AgentSkill {
    return AgentSkill.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentSkill>, I>>(object: I): AgentSkill {
    const message = createBaseAgentSkill();
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.inputSchema = (object.inputSchema !== undefined && object.inputSchema !== null)
      ? SchemaRef.fromPartial(object.inputSchema)
      : undefined;
    message.outputSchema = (object.outputSchema !== undefined && object.outputSchema !== null)
      ? SchemaRef.fromPartial(object.outputSchema)
      : undefined;
    message.examples = object.examples?.map((e) => SkillExample.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSchemaRef(): SchemaRef {
  return { schema: undefined };
}

export const SchemaRef: MessageFns<SchemaRef> = {
  fromJSON(object: any): SchemaRef {
    return {
      schema: isSet(object.ref)
        ? { $case: "ref", ref: globalThis.String(object.ref) }
        : isSet(object.inline)
        ? { $case: "inline", inline: object.inline }
        : undefined,
    };
  },

  toJSON(message: SchemaRef): unknown {
    const obj: any = {};
    if (message.schema?.$case === "ref") {
      obj.ref = message.schema.ref;
    } else if (message.schema?.$case === "inline") {
      obj.inline = message.schema.inline;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SchemaRef>, I>>(base?: I): SchemaRef {
    return SchemaRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SchemaRef>, I>>(object: I): SchemaRef {
    const message = createBaseSchemaRef();
    switch (object.schema?.$case) {
      case "ref": {
        if (object.schema?.ref !== undefined && object.schema?.ref !== null) {
          message.schema = { $case: "ref", ref: object.schema.ref };
        }
        break;
      }
      case "inline": {
        if (object.schema?.inline !== undefined && object.schema?.inline !== null) {
          message.schema = { $case: "inline", inline: object.schema.inline };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSkillExample(): SkillExample {
  return { input: undefined, output: undefined, description: undefined };
}

export const SkillExample: MessageFns<SkillExample> = {
  fromJSON(object: any): SkillExample {
    return {
      input: isSet(object?.input) ? object.input : undefined,
      output: isSet(object?.output) ? object.output : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
    };
  },

  toJSON(message: SkillExample): unknown {
    const obj: any = {};
    if (message.input !== undefined) {
      obj.input = message.input;
    }
    if (message.output !== undefined) {
      obj.output = message.output;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillExample>, I>>(base?: I): SkillExample {
    return SkillExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillExample>, I>>(object: I): SkillExample {
    const message = createBaseSkillExample();
    message.input = object.input ?? undefined;
    message.output = object.output ?? undefined;
    message.description = object.description ?? undefined;
    return message;
  },
};

function createBaseAgentDependency(): AgentDependency {
  return { dependency: undefined };
}

export const AgentDependency: MessageFns<AgentDependency> = {
  fromJSON(object: any): AgentDependency {
    return {
      dependency: isSet(object.tool)
        ? { $case: "tool", tool: globalThis.String(object.tool) }
        : isSet(object.agent)
        ? { $case: "agent", agent: globalThis.String(object.agent) }
        : isSet(object.server)
        ? { $case: "server", server: ServerDependency.fromJSON(object.server) }
        : undefined,
    };
  },

  toJSON(message: AgentDependency): unknown {
    const obj: any = {};
    if (message.dependency?.$case === "tool") {
      obj.tool = message.dependency.tool;
    } else if (message.dependency?.$case === "agent") {
      obj.agent = message.dependency.agent;
    } else if (message.dependency?.$case === "server") {
      obj.server = ServerDependency.toJSON(message.dependency.server);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentDependency>, I>>(base?: I): AgentDependency {
    return AgentDependency.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentDependency>, I>>(object: I): AgentDependency {
    const message = createBaseAgentDependency();
    switch (object.dependency?.$case) {
      case "tool": {
        if (object.dependency?.tool !== undefined && object.dependency?.tool !== null) {
          message.dependency = { $case: "tool", tool: object.dependency.tool };
        }
        break;
      }
      case "agent": {
        if (object.dependency?.agent !== undefined && object.dependency?.agent !== null) {
          message.dependency = { $case: "agent", agent: object.dependency.agent };
        }
        break;
      }
      case "server": {
        if (object.dependency?.server !== undefined && object.dependency?.server !== null) {
          message.dependency = { $case: "server", server: ServerDependency.fromPartial(object.dependency.server) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseServerDependency(): ServerDependency {
  return { name: "", versionConstraint: undefined, tools: [] };
}

export const ServerDependency: MessageFns<ServerDependency> = {
  fromJSON(object: any): ServerDependency {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      versionConstraint: isSet(object.versionConstraint)
        ? globalThis.String(object.versionConstraint)
        : isSet(object.version_constraint)
        ? globalThis.String(object.version_constraint)
        : undefined,
      tools: globalThis.Array.isArray(object?.tools)
        ? object.tools.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ServerDependency): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.versionConstraint !== undefined) {
      obj.versionConstraint = message.versionConstraint;
    }
    if (message.tools?.length) {
      obj.tools = message.tools;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerDependency>, I>>(base?: I): ServerDependency {
    return ServerDependency.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerDependency>, I>>(object: I): ServerDependency {
    const message = createBaseServerDependency();
    message.name = object.name ?? "";
    message.versionConstraint = object.versionConstraint ?? undefined;
    message.tools = object.tools?.map((e) => e) || [];
    return message;
  },
};

function createBaseToolDefinition(): ToolDefinition {
  return {
    name: "",
    description: undefined,
    implementation: undefined,
    inputSchema: undefined,
    outputTransform: undefined,
    version: undefined,
    metadata: {},
  };
}

export const ToolDefinition: MessageFns<ToolDefinition> = {
  fromJSON(object: any): ToolDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      implementation: isSet(object.source)
        ? { $case: "source", source: SourceTool.fromJSON(object.source) }
        : isSet(object.spec)
        ? { $case: "spec", spec: PatternSpec.fromJSON(object.spec) }
        : undefined,
      inputSchema: isObject(object.inputSchema)
        ? object.inputSchema
        : isObject(object.input_schema)
        ? object.input_schema
        : undefined,
      outputTransform: isSet(object.outputTransform)
        ? OutputTransform.fromJSON(object.outputTransform)
        : isSet(object.output_transform)
        ? OutputTransform.fromJSON(object.output_transform)
        : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: any | undefined }, [key, value]: [string, any]) => {
            acc[key] = value as any | undefined;
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ToolDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.implementation?.$case === "source") {
      obj.source = SourceTool.toJSON(message.implementation.source);
    } else if (message.implementation?.$case === "spec") {
      obj.spec = PatternSpec.toJSON(message.implementation.spec);
    }
    if (message.inputSchema !== undefined) {
      obj.inputSchema = message.inputSchema;
    }
    if (message.outputTransform !== undefined) {
      obj.outputTransform = OutputTransform.toJSON(message.outputTransform);
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, any | undefined][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolDefinition>, I>>(base?: I): ToolDefinition {
    return ToolDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolDefinition>, I>>(object: I): ToolDefinition {
    const message = createBaseToolDefinition();
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    switch (object.implementation?.$case) {
      case "source": {
        if (object.implementation?.source !== undefined && object.implementation?.source !== null) {
          message.implementation = { $case: "source", source: SourceTool.fromPartial(object.implementation.source) };
        }
        break;
      }
      case "spec": {
        if (object.implementation?.spec !== undefined && object.implementation?.spec !== null) {
          message.implementation = { $case: "spec", spec: PatternSpec.fromPartial(object.implementation.spec) };
        }
        break;
      }
    }
    message.inputSchema = object.inputSchema ?? undefined;
    message.outputTransform = (object.outputTransform !== undefined && object.outputTransform !== null)
      ? OutputTransform.fromPartial(object.outputTransform)
      : undefined;
    message.version = object.version ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, any | undefined][]).reduce(
      (acc: { [key: string]: any | undefined }, [key, value]: [string, any | undefined]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseToolDefinition_MetadataEntry(): ToolDefinition_MetadataEntry {
  return { key: "", value: undefined };
}

export const ToolDefinition_MetadataEntry: MessageFns<ToolDefinition_MetadataEntry> = {
  fromJSON(object: any): ToolDefinition_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: ToolDefinition_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolDefinition_MetadataEntry>, I>>(base?: I): ToolDefinition_MetadataEntry {
    return ToolDefinition_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolDefinition_MetadataEntry>, I>>(object: I): ToolDefinition_MetadataEntry {
    const message = createBaseToolDefinition_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseSourceTool(): SourceTool {
  return { server: "", tool: "", defaults: {}, hideFields: [], serverVersion: undefined };
}

export const SourceTool: MessageFns<SourceTool> = {
  fromJSON(object: any): SourceTool {
    return {
      server: isSet(object.server) ? globalThis.String(object.server) : "",
      tool: isSet(object.tool) ? globalThis.String(object.tool) : "",
      defaults: isObject(object.defaults)
        ? (globalThis.Object.entries(object.defaults) as [string, any][]).reduce(
          (acc: { [key: string]: any | undefined }, [key, value]: [string, any]) => {
            acc[key] = value as any | undefined;
            return acc;
          },
          {},
        )
        : {},
      hideFields: globalThis.Array.isArray(object?.hideFields)
        ? object.hideFields.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.hide_fields)
        ? object.hide_fields.map((e: any) => globalThis.String(e))
        : [],
      serverVersion: isSet(object.serverVersion)
        ? globalThis.String(object.serverVersion)
        : isSet(object.server_version)
        ? globalThis.String(object.server_version)
        : undefined,
    };
  },

  toJSON(message: SourceTool): unknown {
    const obj: any = {};
    if (message.server !== "") {
      obj.server = message.server;
    }
    if (message.tool !== "") {
      obj.tool = message.tool;
    }
    if (message.defaults) {
      const entries = globalThis.Object.entries(message.defaults) as [string, any | undefined][];
      if (entries.length > 0) {
        obj.defaults = {};
        entries.forEach(([k, v]) => {
          obj.defaults[k] = v;
        });
      }
    }
    if (message.hideFields?.length) {
      obj.hideFields = message.hideFields;
    }
    if (message.serverVersion !== undefined) {
      obj.serverVersion = message.serverVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceTool>, I>>(base?: I): SourceTool {
    return SourceTool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceTool>, I>>(object: I): SourceTool {
    const message = createBaseSourceTool();
    message.server = object.server ?? "";
    message.tool = object.tool ?? "";
    message.defaults = (globalThis.Object.entries(object.defaults ?? {}) as [string, any | undefined][]).reduce(
      (acc: { [key: string]: any | undefined }, [key, value]: [string, any | undefined]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.hideFields = object.hideFields?.map((e) => e) || [];
    message.serverVersion = object.serverVersion ?? undefined;
    return message;
  },
};

function createBaseSourceTool_DefaultsEntry(): SourceTool_DefaultsEntry {
  return { key: "", value: undefined };
}

export const SourceTool_DefaultsEntry: MessageFns<SourceTool_DefaultsEntry> = {
  fromJSON(object: any): SourceTool_DefaultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: SourceTool_DefaultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceTool_DefaultsEntry>, I>>(base?: I): SourceTool_DefaultsEntry {
    return SourceTool_DefaultsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceTool_DefaultsEntry>, I>>(object: I): SourceTool_DefaultsEntry {
    const message = createBaseSourceTool_DefaultsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBasePatternSpec(): PatternSpec {
  return { pattern: undefined };
}

export const PatternSpec: MessageFns<PatternSpec> = {
  fromJSON(object: any): PatternSpec {
    return {
      pattern: isSet(object.pipeline)
        ? { $case: "pipeline", pipeline: PipelineSpec.fromJSON(object.pipeline) }
        : isSet(object.scatterGather)
        ? { $case: "scatterGather", scatterGather: ScatterGatherSpec.fromJSON(object.scatterGather) }
        : isSet(object.scatter_gather)
        ? { $case: "scatterGather", scatterGather: ScatterGatherSpec.fromJSON(object.scatter_gather) }
        : isSet(object.filter)
        ? { $case: "filter", filter: FilterSpec.fromJSON(object.filter) }
        : isSet(object.schemaMap)
        ? { $case: "schemaMap", schemaMap: SchemaMapSpec.fromJSON(object.schemaMap) }
        : isSet(object.schema_map)
        ? { $case: "schemaMap", schemaMap: SchemaMapSpec.fromJSON(object.schema_map) }
        : isSet(object.mapEach)
        ? { $case: "mapEach", mapEach: MapEachSpec.fromJSON(object.mapEach) }
        : isSet(object.map_each)
        ? { $case: "mapEach", mapEach: MapEachSpec.fromJSON(object.map_each) }
        : isSet(object.retry)
        ? { $case: "retry", retry: RetrySpec.fromJSON(object.retry) }
        : isSet(object.timeout)
        ? { $case: "timeout", timeout: TimeoutSpec.fromJSON(object.timeout) }
        : isSet(object.cache)
        ? { $case: "cache", cache: CacheSpec.fromJSON(object.cache) }
        : isSet(object.idempotent)
        ? { $case: "idempotent", idempotent: IdempotentSpec.fromJSON(object.idempotent) }
        : isSet(object.circuitBreaker)
        ? { $case: "circuitBreaker", circuitBreaker: CircuitBreakerSpec.fromJSON(object.circuitBreaker) }
        : isSet(object.circuit_breaker)
        ? { $case: "circuitBreaker", circuitBreaker: CircuitBreakerSpec.fromJSON(object.circuit_breaker) }
        : isSet(object.deadLetter)
        ? { $case: "deadLetter", deadLetter: DeadLetterSpec.fromJSON(object.deadLetter) }
        : isSet(object.dead_letter)
        ? { $case: "deadLetter", deadLetter: DeadLetterSpec.fromJSON(object.dead_letter) }
        : isSet(object.saga)
        ? { $case: "saga", saga: SagaSpec.fromJSON(object.saga) }
        : isSet(object.claimCheck)
        ? { $case: "claimCheck", claimCheck: ClaimCheckSpec.fromJSON(object.claimCheck) }
        : isSet(object.claim_check)
        ? { $case: "claimCheck", claimCheck: ClaimCheckSpec.fromJSON(object.claim_check) }
        : undefined,
    };
  },

  toJSON(message: PatternSpec): unknown {
    const obj: any = {};
    if (message.pattern?.$case === "pipeline") {
      obj.pipeline = PipelineSpec.toJSON(message.pattern.pipeline);
    } else if (message.pattern?.$case === "scatterGather") {
      obj.scatterGather = ScatterGatherSpec.toJSON(message.pattern.scatterGather);
    } else if (message.pattern?.$case === "filter") {
      obj.filter = FilterSpec.toJSON(message.pattern.filter);
    } else if (message.pattern?.$case === "schemaMap") {
      obj.schemaMap = SchemaMapSpec.toJSON(message.pattern.schemaMap);
    } else if (message.pattern?.$case === "mapEach") {
      obj.mapEach = MapEachSpec.toJSON(message.pattern.mapEach);
    } else if (message.pattern?.$case === "retry") {
      obj.retry = RetrySpec.toJSON(message.pattern.retry);
    } else if (message.pattern?.$case === "timeout") {
      obj.timeout = TimeoutSpec.toJSON(message.pattern.timeout);
    } else if (message.pattern?.$case === "cache") {
      obj.cache = CacheSpec.toJSON(message.pattern.cache);
    } else if (message.pattern?.$case === "idempotent") {
      obj.idempotent = IdempotentSpec.toJSON(message.pattern.idempotent);
    } else if (message.pattern?.$case === "circuitBreaker") {
      obj.circuitBreaker = CircuitBreakerSpec.toJSON(message.pattern.circuitBreaker);
    } else if (message.pattern?.$case === "deadLetter") {
      obj.deadLetter = DeadLetterSpec.toJSON(message.pattern.deadLetter);
    } else if (message.pattern?.$case === "saga") {
      obj.saga = SagaSpec.toJSON(message.pattern.saga);
    } else if (message.pattern?.$case === "claimCheck") {
      obj.claimCheck = ClaimCheckSpec.toJSON(message.pattern.claimCheck);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatternSpec>, I>>(base?: I): PatternSpec {
    return PatternSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatternSpec>, I>>(object: I): PatternSpec {
    const message = createBasePatternSpec();
    switch (object.pattern?.$case) {
      case "pipeline": {
        if (object.pattern?.pipeline !== undefined && object.pattern?.pipeline !== null) {
          message.pattern = { $case: "pipeline", pipeline: PipelineSpec.fromPartial(object.pattern.pipeline) };
        }
        break;
      }
      case "scatterGather": {
        if (object.pattern?.scatterGather !== undefined && object.pattern?.scatterGather !== null) {
          message.pattern = {
            $case: "scatterGather",
            scatterGather: ScatterGatherSpec.fromPartial(object.pattern.scatterGather),
          };
        }
        break;
      }
      case "filter": {
        if (object.pattern?.filter !== undefined && object.pattern?.filter !== null) {
          message.pattern = { $case: "filter", filter: FilterSpec.fromPartial(object.pattern.filter) };
        }
        break;
      }
      case "schemaMap": {
        if (object.pattern?.schemaMap !== undefined && object.pattern?.schemaMap !== null) {
          message.pattern = { $case: "schemaMap", schemaMap: SchemaMapSpec.fromPartial(object.pattern.schemaMap) };
        }
        break;
      }
      case "mapEach": {
        if (object.pattern?.mapEach !== undefined && object.pattern?.mapEach !== null) {
          message.pattern = { $case: "mapEach", mapEach: MapEachSpec.fromPartial(object.pattern.mapEach) };
        }
        break;
      }
      case "retry": {
        if (object.pattern?.retry !== undefined && object.pattern?.retry !== null) {
          message.pattern = { $case: "retry", retry: RetrySpec.fromPartial(object.pattern.retry) };
        }
        break;
      }
      case "timeout": {
        if (object.pattern?.timeout !== undefined && object.pattern?.timeout !== null) {
          message.pattern = { $case: "timeout", timeout: TimeoutSpec.fromPartial(object.pattern.timeout) };
        }
        break;
      }
      case "cache": {
        if (object.pattern?.cache !== undefined && object.pattern?.cache !== null) {
          message.pattern = { $case: "cache", cache: CacheSpec.fromPartial(object.pattern.cache) };
        }
        break;
      }
      case "idempotent": {
        if (object.pattern?.idempotent !== undefined && object.pattern?.idempotent !== null) {
          message.pattern = { $case: "idempotent", idempotent: IdempotentSpec.fromPartial(object.pattern.idempotent) };
        }
        break;
      }
      case "circuitBreaker": {
        if (object.pattern?.circuitBreaker !== undefined && object.pattern?.circuitBreaker !== null) {
          message.pattern = {
            $case: "circuitBreaker",
            circuitBreaker: CircuitBreakerSpec.fromPartial(object.pattern.circuitBreaker),
          };
        }
        break;
      }
      case "deadLetter": {
        if (object.pattern?.deadLetter !== undefined && object.pattern?.deadLetter !== null) {
          message.pattern = { $case: "deadLetter", deadLetter: DeadLetterSpec.fromPartial(object.pattern.deadLetter) };
        }
        break;
      }
      case "saga": {
        if (object.pattern?.saga !== undefined && object.pattern?.saga !== null) {
          message.pattern = { $case: "saga", saga: SagaSpec.fromPartial(object.pattern.saga) };
        }
        break;
      }
      case "claimCheck": {
        if (object.pattern?.claimCheck !== undefined && object.pattern?.claimCheck !== null) {
          message.pattern = { $case: "claimCheck", claimCheck: ClaimCheckSpec.fromPartial(object.pattern.claimCheck) };
        }
        break;
      }
    }
    return message;
  },
};

function createBasePipelineSpec(): PipelineSpec {
  return { steps: [] };
}

export const PipelineSpec: MessageFns<PipelineSpec> = {
  fromJSON(object: any): PipelineSpec {
    return {
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => PipelineStep.fromJSON(e)) : [],
    };
  },

  toJSON(message: PipelineSpec): unknown {
    const obj: any = {};
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => PipelineStep.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PipelineSpec>, I>>(base?: I): PipelineSpec {
    return PipelineSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PipelineSpec>, I>>(object: I): PipelineSpec {
    const message = createBasePipelineSpec();
    message.steps = object.steps?.map((e) => PipelineStep.fromPartial(e)) || [];
    return message;
  },
};

function createBasePipelineStep(): PipelineStep {
  return { id: "", operation: undefined, input: undefined };
}

export const PipelineStep: MessageFns<PipelineStep> = {
  fromJSON(object: any): PipelineStep {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      operation: isSet(object.operation) ? StepOperation.fromJSON(object.operation) : undefined,
      input: isSet(object.input) ? DataBinding.fromJSON(object.input) : undefined,
    };
  },

  toJSON(message: PipelineStep): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.operation !== undefined) {
      obj.operation = StepOperation.toJSON(message.operation);
    }
    if (message.input !== undefined) {
      obj.input = DataBinding.toJSON(message.input);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PipelineStep>, I>>(base?: I): PipelineStep {
    return PipelineStep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PipelineStep>, I>>(object: I): PipelineStep {
    const message = createBasePipelineStep();
    message.id = object.id ?? "";
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? StepOperation.fromPartial(object.operation)
      : undefined;
    message.input = (object.input !== undefined && object.input !== null)
      ? DataBinding.fromPartial(object.input)
      : undefined;
    return message;
  },
};

function createBaseStepOperation(): StepOperation {
  return { op: undefined };
}

export const StepOperation: MessageFns<StepOperation> = {
  fromJSON(object: any): StepOperation {
    return {
      op: isSet(object.tool)
        ? { $case: "tool", tool: ToolCall.fromJSON(object.tool) }
        : isSet(object.pattern)
        ? { $case: "pattern", pattern: PatternSpec.fromJSON(object.pattern) }
        : isSet(object.agent)
        ? { $case: "agent", agent: AgentCall.fromJSON(object.agent) }
        : undefined,
    };
  },

  toJSON(message: StepOperation): unknown {
    const obj: any = {};
    if (message.op?.$case === "tool") {
      obj.tool = ToolCall.toJSON(message.op.tool);
    } else if (message.op?.$case === "pattern") {
      obj.pattern = PatternSpec.toJSON(message.op.pattern);
    } else if (message.op?.$case === "agent") {
      obj.agent = AgentCall.toJSON(message.op.agent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepOperation>, I>>(base?: I): StepOperation {
    return StepOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepOperation>, I>>(object: I): StepOperation {
    const message = createBaseStepOperation();
    switch (object.op?.$case) {
      case "tool": {
        if (object.op?.tool !== undefined && object.op?.tool !== null) {
          message.op = { $case: "tool", tool: ToolCall.fromPartial(object.op.tool) };
        }
        break;
      }
      case "pattern": {
        if (object.op?.pattern !== undefined && object.op?.pattern !== null) {
          message.op = { $case: "pattern", pattern: PatternSpec.fromPartial(object.op.pattern) };
        }
        break;
      }
      case "agent": {
        if (object.op?.agent !== undefined && object.op?.agent !== null) {
          message.op = { $case: "agent", agent: AgentCall.fromPartial(object.op.agent) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseAgentCall(): AgentCall {
  return { name: "", skill: undefined, version: undefined };
}

export const AgentCall: MessageFns<AgentCall> = {
  fromJSON(object: any): AgentCall {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      skill: isSet(object.skill) ? globalThis.String(object.skill) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
    };
  },

  toJSON(message: AgentCall): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.skill !== undefined) {
      obj.skill = message.skill;
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentCall>, I>>(base?: I): AgentCall {
    return AgentCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentCall>, I>>(object: I): AgentCall {
    const message = createBaseAgentCall();
    message.name = object.name ?? "";
    message.skill = object.skill ?? undefined;
    message.version = object.version ?? undefined;
    return message;
  },
};

function createBaseToolCall(): ToolCall {
  return { name: "", server: undefined, serverVersion: undefined };
}

export const ToolCall: MessageFns<ToolCall> = {
  fromJSON(object: any): ToolCall {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      server: isSet(object.server) ? globalThis.String(object.server) : undefined,
      serverVersion: isSet(object.serverVersion)
        ? globalThis.String(object.serverVersion)
        : isSet(object.server_version)
        ? globalThis.String(object.server_version)
        : undefined,
    };
  },

  toJSON(message: ToolCall): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.server !== undefined) {
      obj.server = message.server;
    }
    if (message.serverVersion !== undefined) {
      obj.serverVersion = message.serverVersion;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCall>, I>>(base?: I): ToolCall {
    return ToolCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCall>, I>>(object: I): ToolCall {
    const message = createBaseToolCall();
    message.name = object.name ?? "";
    message.server = object.server ?? undefined;
    message.serverVersion = object.serverVersion ?? undefined;
    return message;
  },
};

function createBaseDataBinding(): DataBinding {
  return { source: undefined };
}

export const DataBinding: MessageFns<DataBinding> = {
  fromJSON(object: any): DataBinding {
    return {
      source: isSet(object.input)
        ? { $case: "input", input: InputBinding.fromJSON(object.input) }
        : isSet(object.step)
        ? { $case: "step", step: StepBinding.fromJSON(object.step) }
        : isSet(object.constant)
        ? { $case: "constant", constant: object.constant }
        : isSet(object.construct)
        ? { $case: "construct", construct: ConstructBinding.fromJSON(object.construct) }
        : undefined,
    };
  },

  toJSON(message: DataBinding): unknown {
    const obj: any = {};
    if (message.source?.$case === "input") {
      obj.input = InputBinding.toJSON(message.source.input);
    } else if (message.source?.$case === "step") {
      obj.step = StepBinding.toJSON(message.source.step);
    } else if (message.source?.$case === "constant") {
      obj.constant = message.source.constant;
    } else if (message.source?.$case === "construct") {
      obj.construct = ConstructBinding.toJSON(message.source.construct);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataBinding>, I>>(base?: I): DataBinding {
    return DataBinding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataBinding>, I>>(object: I): DataBinding {
    const message = createBaseDataBinding();
    switch (object.source?.$case) {
      case "input": {
        if (object.source?.input !== undefined && object.source?.input !== null) {
          message.source = { $case: "input", input: InputBinding.fromPartial(object.source.input) };
        }
        break;
      }
      case "step": {
        if (object.source?.step !== undefined && object.source?.step !== null) {
          message.source = { $case: "step", step: StepBinding.fromPartial(object.source.step) };
        }
        break;
      }
      case "constant": {
        if (object.source?.constant !== undefined && object.source?.constant !== null) {
          message.source = { $case: "constant", constant: object.source.constant };
        }
        break;
      }
      case "construct": {
        if (object.source?.construct !== undefined && object.source?.construct !== null) {
          message.source = { $case: "construct", construct: ConstructBinding.fromPartial(object.source.construct) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseInputBinding(): InputBinding {
  return { path: "" };
}

export const InputBinding: MessageFns<InputBinding> = {
  fromJSON(object: any): InputBinding {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: InputBinding): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputBinding>, I>>(base?: I): InputBinding {
    return InputBinding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputBinding>, I>>(object: I): InputBinding {
    const message = createBaseInputBinding();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseStepBinding(): StepBinding {
  return { stepId: "", path: "" };
}

export const StepBinding: MessageFns<StepBinding> = {
  fromJSON(object: any): StepBinding {
    return {
      stepId: isSet(object.stepId)
        ? globalThis.String(object.stepId)
        : isSet(object.step_id)
        ? globalThis.String(object.step_id)
        : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: StepBinding): unknown {
    const obj: any = {};
    if (message.stepId !== "") {
      obj.stepId = message.stepId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepBinding>, I>>(base?: I): StepBinding {
    return StepBinding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepBinding>, I>>(object: I): StepBinding {
    const message = createBaseStepBinding();
    message.stepId = object.stepId ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseConstructBinding(): ConstructBinding {
  return { fields: {} };
}

export const ConstructBinding: MessageFns<ConstructBinding> = {
  fromJSON(object: any): ConstructBinding {
    return {
      fields: isObject(object.fields)
        ? (globalThis.Object.entries(object.fields) as [string, any][]).reduce(
          (acc: { [key: string]: DataBinding }, [key, value]: [string, any]) => {
            acc[key] = DataBinding.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ConstructBinding): unknown {
    const obj: any = {};
    if (message.fields) {
      const entries = globalThis.Object.entries(message.fields) as [string, DataBinding][];
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = DataBinding.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConstructBinding>, I>>(base?: I): ConstructBinding {
    return ConstructBinding.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConstructBinding>, I>>(object: I): ConstructBinding {
    const message = createBaseConstructBinding();
    message.fields = (globalThis.Object.entries(object.fields ?? {}) as [string, DataBinding][]).reduce(
      (acc: { [key: string]: DataBinding }, [key, value]: [string, DataBinding]) => {
        if (value !== undefined) {
          acc[key] = DataBinding.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseConstructBinding_FieldsEntry(): ConstructBinding_FieldsEntry {
  return { key: "", value: undefined };
}

export const ConstructBinding_FieldsEntry: MessageFns<ConstructBinding_FieldsEntry> = {
  fromJSON(object: any): ConstructBinding_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DataBinding.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ConstructBinding_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DataBinding.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConstructBinding_FieldsEntry>, I>>(base?: I): ConstructBinding_FieldsEntry {
    return ConstructBinding_FieldsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConstructBinding_FieldsEntry>, I>>(object: I): ConstructBinding_FieldsEntry {
    const message = createBaseConstructBinding_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DataBinding.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseScatterGatherSpec(): ScatterGatherSpec {
  return { targets: [], aggregation: undefined, timeoutMs: undefined, failFast: false };
}

export const ScatterGatherSpec: MessageFns<ScatterGatherSpec> = {
  fromJSON(object: any): ScatterGatherSpec {
    return {
      targets: globalThis.Array.isArray(object?.targets)
        ? object.targets.map((e: any) => ScatterTarget.fromJSON(e))
        : [],
      aggregation: isSet(object.aggregation) ? AggregationStrategy.fromJSON(object.aggregation) : undefined,
      timeoutMs: isSet(object.timeoutMs)
        ? globalThis.Number(object.timeoutMs)
        : isSet(object.timeout_ms)
        ? globalThis.Number(object.timeout_ms)
        : undefined,
      failFast: isSet(object.failFast)
        ? globalThis.Boolean(object.failFast)
        : isSet(object.fail_fast)
        ? globalThis.Boolean(object.fail_fast)
        : false,
    };
  },

  toJSON(message: ScatterGatherSpec): unknown {
    const obj: any = {};
    if (message.targets?.length) {
      obj.targets = message.targets.map((e) => ScatterTarget.toJSON(e));
    }
    if (message.aggregation !== undefined) {
      obj.aggregation = AggregationStrategy.toJSON(message.aggregation);
    }
    if (message.timeoutMs !== undefined) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    if (message.failFast !== false) {
      obj.failFast = message.failFast;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScatterGatherSpec>, I>>(base?: I): ScatterGatherSpec {
    return ScatterGatherSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScatterGatherSpec>, I>>(object: I): ScatterGatherSpec {
    const message = createBaseScatterGatherSpec();
    message.targets = object.targets?.map((e) => ScatterTarget.fromPartial(e)) || [];
    message.aggregation = (object.aggregation !== undefined && object.aggregation !== null)
      ? AggregationStrategy.fromPartial(object.aggregation)
      : undefined;
    message.timeoutMs = object.timeoutMs ?? undefined;
    message.failFast = object.failFast ?? false;
    return message;
  },
};

function createBaseScatterTarget(): ScatterTarget {
  return { target: undefined };
}

export const ScatterTarget: MessageFns<ScatterTarget> = {
  fromJSON(object: any): ScatterTarget {
    return {
      target: isSet(object.tool)
        ? { $case: "tool", tool: globalThis.String(object.tool) }
        : isSet(object.pattern)
        ? { $case: "pattern", pattern: PatternSpec.fromJSON(object.pattern) }
        : undefined,
    };
  },

  toJSON(message: ScatterTarget): unknown {
    const obj: any = {};
    if (message.target?.$case === "tool") {
      obj.tool = message.target.tool;
    } else if (message.target?.$case === "pattern") {
      obj.pattern = PatternSpec.toJSON(message.target.pattern);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScatterTarget>, I>>(base?: I): ScatterTarget {
    return ScatterTarget.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScatterTarget>, I>>(object: I): ScatterTarget {
    const message = createBaseScatterTarget();
    switch (object.target?.$case) {
      case "tool": {
        if (object.target?.tool !== undefined && object.target?.tool !== null) {
          message.target = { $case: "tool", tool: object.target.tool };
        }
        break;
      }
      case "pattern": {
        if (object.target?.pattern !== undefined && object.target?.pattern !== null) {
          message.target = { $case: "pattern", pattern: PatternSpec.fromPartial(object.target.pattern) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseAggregationStrategy(): AggregationStrategy {
  return { ops: [] };
}

export const AggregationStrategy: MessageFns<AggregationStrategy> = {
  fromJSON(object: any): AggregationStrategy {
    return { ops: globalThis.Array.isArray(object?.ops) ? object.ops.map((e: any) => AggregationOp.fromJSON(e)) : [] };
  },

  toJSON(message: AggregationStrategy): unknown {
    const obj: any = {};
    if (message.ops?.length) {
      obj.ops = message.ops.map((e) => AggregationOp.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AggregationStrategy>, I>>(base?: I): AggregationStrategy {
    return AggregationStrategy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AggregationStrategy>, I>>(object: I): AggregationStrategy {
    const message = createBaseAggregationStrategy();
    message.ops = object.ops?.map((e) => AggregationOp.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAggregationOp(): AggregationOp {
  return { op: undefined };
}

export const AggregationOp: MessageFns<AggregationOp> = {
  fromJSON(object: any): AggregationOp {
    return {
      op: isSet(object.flatten)
        ? { $case: "flatten", flatten: globalThis.Boolean(object.flatten) }
        : isSet(object.sort)
        ? { $case: "sort", sort: SortOp.fromJSON(object.sort) }
        : isSet(object.dedupe)
        ? { $case: "dedupe", dedupe: DedupeOp.fromJSON(object.dedupe) }
        : isSet(object.limit)
        ? { $case: "limit", limit: LimitOp.fromJSON(object.limit) }
        : isSet(object.concat)
        ? { $case: "concat", concat: globalThis.Boolean(object.concat) }
        : isSet(object.merge)
        ? { $case: "merge", merge: globalThis.Boolean(object.merge) }
        : undefined,
    };
  },

  toJSON(message: AggregationOp): unknown {
    const obj: any = {};
    if (message.op?.$case === "flatten") {
      obj.flatten = message.op.flatten;
    } else if (message.op?.$case === "sort") {
      obj.sort = SortOp.toJSON(message.op.sort);
    } else if (message.op?.$case === "dedupe") {
      obj.dedupe = DedupeOp.toJSON(message.op.dedupe);
    } else if (message.op?.$case === "limit") {
      obj.limit = LimitOp.toJSON(message.op.limit);
    } else if (message.op?.$case === "concat") {
      obj.concat = message.op.concat;
    } else if (message.op?.$case === "merge") {
      obj.merge = message.op.merge;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AggregationOp>, I>>(base?: I): AggregationOp {
    return AggregationOp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AggregationOp>, I>>(object: I): AggregationOp {
    const message = createBaseAggregationOp();
    switch (object.op?.$case) {
      case "flatten": {
        if (object.op?.flatten !== undefined && object.op?.flatten !== null) {
          message.op = { $case: "flatten", flatten: object.op.flatten };
        }
        break;
      }
      case "sort": {
        if (object.op?.sort !== undefined && object.op?.sort !== null) {
          message.op = { $case: "sort", sort: SortOp.fromPartial(object.op.sort) };
        }
        break;
      }
      case "dedupe": {
        if (object.op?.dedupe !== undefined && object.op?.dedupe !== null) {
          message.op = { $case: "dedupe", dedupe: DedupeOp.fromPartial(object.op.dedupe) };
        }
        break;
      }
      case "limit": {
        if (object.op?.limit !== undefined && object.op?.limit !== null) {
          message.op = { $case: "limit", limit: LimitOp.fromPartial(object.op.limit) };
        }
        break;
      }
      case "concat": {
        if (object.op?.concat !== undefined && object.op?.concat !== null) {
          message.op = { $case: "concat", concat: object.op.concat };
        }
        break;
      }
      case "merge": {
        if (object.op?.merge !== undefined && object.op?.merge !== null) {
          message.op = { $case: "merge", merge: object.op.merge };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSortOp(): SortOp {
  return { field: "", order: "" };
}

export const SortOp: MessageFns<SortOp> = {
  fromJSON(object: any): SortOp {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      order: isSet(object.order) ? globalThis.String(object.order) : "",
    };
  },

  toJSON(message: SortOp): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.order !== "") {
      obj.order = message.order;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SortOp>, I>>(base?: I): SortOp {
    return SortOp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SortOp>, I>>(object: I): SortOp {
    const message = createBaseSortOp();
    message.field = object.field ?? "";
    message.order = object.order ?? "";
    return message;
  },
};

function createBaseDedupeOp(): DedupeOp {
  return { field: "" };
}

export const DedupeOp: MessageFns<DedupeOp> = {
  fromJSON(object: any): DedupeOp {
    return { field: isSet(object.field) ? globalThis.String(object.field) : "" };
  },

  toJSON(message: DedupeOp): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DedupeOp>, I>>(base?: I): DedupeOp {
    return DedupeOp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DedupeOp>, I>>(object: I): DedupeOp {
    const message = createBaseDedupeOp();
    message.field = object.field ?? "";
    return message;
  },
};

function createBaseLimitOp(): LimitOp {
  return { count: 0 };
}

export const LimitOp: MessageFns<LimitOp> = {
  fromJSON(object: any): LimitOp {
    return { count: isSet(object.count) ? globalThis.Number(object.count) : 0 };
  },

  toJSON(message: LimitOp): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LimitOp>, I>>(base?: I): LimitOp {
    return LimitOp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LimitOp>, I>>(object: I): LimitOp {
    const message = createBaseLimitOp();
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseFilterSpec(): FilterSpec {
  return { predicate: undefined };
}

export const FilterSpec: MessageFns<FilterSpec> = {
  fromJSON(object: any): FilterSpec {
    return { predicate: isSet(object.predicate) ? FieldPredicate.fromJSON(object.predicate) : undefined };
  },

  toJSON(message: FilterSpec): unknown {
    const obj: any = {};
    if (message.predicate !== undefined) {
      obj.predicate = FieldPredicate.toJSON(message.predicate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterSpec>, I>>(base?: I): FilterSpec {
    return FilterSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterSpec>, I>>(object: I): FilterSpec {
    const message = createBaseFilterSpec();
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? FieldPredicate.fromPartial(object.predicate)
      : undefined;
    return message;
  },
};

function createBaseFieldPredicate(): FieldPredicate {
  return { field: "", op: "", value: undefined };
}

export const FieldPredicate: MessageFns<FieldPredicate> = {
  fromJSON(object: any): FieldPredicate {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      op: isSet(object.op) ? globalThis.String(object.op) : "",
      value: isSet(object.value) ? PredicateValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: FieldPredicate): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.op !== "") {
      obj.op = message.op;
    }
    if (message.value !== undefined) {
      obj.value = PredicateValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldPredicate>, I>>(base?: I): FieldPredicate {
    return FieldPredicate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldPredicate>, I>>(object: I): FieldPredicate {
    const message = createBaseFieldPredicate();
    message.field = object.field ?? "";
    message.op = object.op ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? PredicateValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePredicateValue(): PredicateValue {
  return { value: undefined };
}

export const PredicateValue: MessageFns<PredicateValue> = {
  fromJSON(object: any): PredicateValue {
    return {
      value: isSet(object.stringValue)
        ? { $case: "stringValue", stringValue: globalThis.String(object.stringValue) }
        : isSet(object.string_value)
        ? { $case: "stringValue", stringValue: globalThis.String(object.string_value) }
        : isSet(object.numberValue)
        ? { $case: "numberValue", numberValue: globalThis.Number(object.numberValue) }
        : isSet(object.number_value)
        ? { $case: "numberValue", numberValue: globalThis.Number(object.number_value) }
        : isSet(object.boolValue)
        ? { $case: "boolValue", boolValue: globalThis.Boolean(object.boolValue) }
        : isSet(object.bool_value)
        ? { $case: "boolValue", boolValue: globalThis.Boolean(object.bool_value) }
        : isSet(object.nullValue)
        ? { $case: "nullValue", nullValue: globalThis.Boolean(object.nullValue) }
        : isSet(object.null_value)
        ? { $case: "nullValue", nullValue: globalThis.Boolean(object.null_value) }
        : isSet(object.listValue)
        ? { $case: "listValue", listValue: ValueList.fromJSON(object.listValue) }
        : isSet(object.list_value)
        ? { $case: "listValue", listValue: ValueList.fromJSON(object.list_value) }
        : undefined,
    };
  },

  toJSON(message: PredicateValue): unknown {
    const obj: any = {};
    if (message.value?.$case === "stringValue") {
      obj.stringValue = message.value.stringValue;
    } else if (message.value?.$case === "numberValue") {
      obj.numberValue = message.value.numberValue;
    } else if (message.value?.$case === "boolValue") {
      obj.boolValue = message.value.boolValue;
    } else if (message.value?.$case === "nullValue") {
      obj.nullValue = message.value.nullValue;
    } else if (message.value?.$case === "listValue") {
      obj.listValue = ValueList.toJSON(message.value.listValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PredicateValue>, I>>(base?: I): PredicateValue {
    return PredicateValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PredicateValue>, I>>(object: I): PredicateValue {
    const message = createBasePredicateValue();
    switch (object.value?.$case) {
      case "stringValue": {
        if (object.value?.stringValue !== undefined && object.value?.stringValue !== null) {
          message.value = { $case: "stringValue", stringValue: object.value.stringValue };
        }
        break;
      }
      case "numberValue": {
        if (object.value?.numberValue !== undefined && object.value?.numberValue !== null) {
          message.value = { $case: "numberValue", numberValue: object.value.numberValue };
        }
        break;
      }
      case "boolValue": {
        if (object.value?.boolValue !== undefined && object.value?.boolValue !== null) {
          message.value = { $case: "boolValue", boolValue: object.value.boolValue };
        }
        break;
      }
      case "nullValue": {
        if (object.value?.nullValue !== undefined && object.value?.nullValue !== null) {
          message.value = { $case: "nullValue", nullValue: object.value.nullValue };
        }
        break;
      }
      case "listValue": {
        if (object.value?.listValue !== undefined && object.value?.listValue !== null) {
          message.value = { $case: "listValue", listValue: ValueList.fromPartial(object.value.listValue) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseValueList(): ValueList {
  return { values: [] };
}

export const ValueList: MessageFns<ValueList> = {
  fromJSON(object: any): ValueList {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => PredicateValue.fromJSON(e)) : [],
    };
  },

  toJSON(message: ValueList): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => PredicateValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValueList>, I>>(base?: I): ValueList {
    return ValueList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValueList>, I>>(object: I): ValueList {
    const message = createBaseValueList();
    message.values = object.values?.map((e) => PredicateValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSchemaMapSpec(): SchemaMapSpec {
  return { mappings: {} };
}

export const SchemaMapSpec: MessageFns<SchemaMapSpec> = {
  fromJSON(object: any): SchemaMapSpec {
    return {
      mappings: isObject(object.mappings)
        ? (globalThis.Object.entries(object.mappings) as [string, any][]).reduce(
          (acc: { [key: string]: FieldSource }, [key, value]: [string, any]) => {
            acc[key] = FieldSource.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: SchemaMapSpec): unknown {
    const obj: any = {};
    if (message.mappings) {
      const entries = globalThis.Object.entries(message.mappings) as [string, FieldSource][];
      if (entries.length > 0) {
        obj.mappings = {};
        entries.forEach(([k, v]) => {
          obj.mappings[k] = FieldSource.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SchemaMapSpec>, I>>(base?: I): SchemaMapSpec {
    return SchemaMapSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SchemaMapSpec>, I>>(object: I): SchemaMapSpec {
    const message = createBaseSchemaMapSpec();
    message.mappings = (globalThis.Object.entries(object.mappings ?? {}) as [string, FieldSource][]).reduce(
      (acc: { [key: string]: FieldSource }, [key, value]: [string, FieldSource]) => {
        if (value !== undefined) {
          acc[key] = FieldSource.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSchemaMapSpec_MappingsEntry(): SchemaMapSpec_MappingsEntry {
  return { key: "", value: undefined };
}

export const SchemaMapSpec_MappingsEntry: MessageFns<SchemaMapSpec_MappingsEntry> = {
  fromJSON(object: any): SchemaMapSpec_MappingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? FieldSource.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SchemaMapSpec_MappingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = FieldSource.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SchemaMapSpec_MappingsEntry>, I>>(base?: I): SchemaMapSpec_MappingsEntry {
    return SchemaMapSpec_MappingsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SchemaMapSpec_MappingsEntry>, I>>(object: I): SchemaMapSpec_MappingsEntry {
    const message = createBaseSchemaMapSpec_MappingsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? FieldSource.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFieldSource(): FieldSource {
  return { source: undefined };
}

export const FieldSource: MessageFns<FieldSource> = {
  fromJSON(object: any): FieldSource {
    return {
      source: isSet(object.path)
        ? { $case: "path", path: globalThis.String(object.path) }
        : isSet(object.literal)
        ? { $case: "literal", literal: LiteralValue.fromJSON(object.literal) }
        : isSet(object.coalesce)
        ? { $case: "coalesce", coalesce: CoalesceSource.fromJSON(object.coalesce) }
        : isSet(object.template)
        ? { $case: "template", template: TemplateSource.fromJSON(object.template) }
        : isSet(object.concat)
        ? { $case: "concat", concat: ConcatSource.fromJSON(object.concat) }
        : isSet(object.nested)
        ? { $case: "nested", nested: SchemaMapSpec.fromJSON(object.nested) }
        : undefined,
    };
  },

  toJSON(message: FieldSource): unknown {
    const obj: any = {};
    if (message.source?.$case === "path") {
      obj.path = message.source.path;
    } else if (message.source?.$case === "literal") {
      obj.literal = LiteralValue.toJSON(message.source.literal);
    } else if (message.source?.$case === "coalesce") {
      obj.coalesce = CoalesceSource.toJSON(message.source.coalesce);
    } else if (message.source?.$case === "template") {
      obj.template = TemplateSource.toJSON(message.source.template);
    } else if (message.source?.$case === "concat") {
      obj.concat = ConcatSource.toJSON(message.source.concat);
    } else if (message.source?.$case === "nested") {
      obj.nested = SchemaMapSpec.toJSON(message.source.nested);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldSource>, I>>(base?: I): FieldSource {
    return FieldSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldSource>, I>>(object: I): FieldSource {
    const message = createBaseFieldSource();
    switch (object.source?.$case) {
      case "path": {
        if (object.source?.path !== undefined && object.source?.path !== null) {
          message.source = { $case: "path", path: object.source.path };
        }
        break;
      }
      case "literal": {
        if (object.source?.literal !== undefined && object.source?.literal !== null) {
          message.source = { $case: "literal", literal: LiteralValue.fromPartial(object.source.literal) };
        }
        break;
      }
      case "coalesce": {
        if (object.source?.coalesce !== undefined && object.source?.coalesce !== null) {
          message.source = { $case: "coalesce", coalesce: CoalesceSource.fromPartial(object.source.coalesce) };
        }
        break;
      }
      case "template": {
        if (object.source?.template !== undefined && object.source?.template !== null) {
          message.source = { $case: "template", template: TemplateSource.fromPartial(object.source.template) };
        }
        break;
      }
      case "concat": {
        if (object.source?.concat !== undefined && object.source?.concat !== null) {
          message.source = { $case: "concat", concat: ConcatSource.fromPartial(object.source.concat) };
        }
        break;
      }
      case "nested": {
        if (object.source?.nested !== undefined && object.source?.nested !== null) {
          message.source = { $case: "nested", nested: SchemaMapSpec.fromPartial(object.source.nested) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseLiteralValue(): LiteralValue {
  return { value: undefined };
}

export const LiteralValue: MessageFns<LiteralValue> = {
  fromJSON(object: any): LiteralValue {
    return {
      value: isSet(object.stringValue)
        ? { $case: "stringValue", stringValue: globalThis.String(object.stringValue) }
        : isSet(object.string_value)
        ? { $case: "stringValue", stringValue: globalThis.String(object.string_value) }
        : isSet(object.numberValue)
        ? { $case: "numberValue", numberValue: globalThis.Number(object.numberValue) }
        : isSet(object.number_value)
        ? { $case: "numberValue", numberValue: globalThis.Number(object.number_value) }
        : isSet(object.boolValue)
        ? { $case: "boolValue", boolValue: globalThis.Boolean(object.boolValue) }
        : isSet(object.bool_value)
        ? { $case: "boolValue", boolValue: globalThis.Boolean(object.bool_value) }
        : isSet(object.nullValue)
        ? { $case: "nullValue", nullValue: globalThis.Boolean(object.nullValue) }
        : isSet(object.null_value)
        ? { $case: "nullValue", nullValue: globalThis.Boolean(object.null_value) }
        : undefined,
    };
  },

  toJSON(message: LiteralValue): unknown {
    const obj: any = {};
    if (message.value?.$case === "stringValue") {
      obj.stringValue = message.value.stringValue;
    } else if (message.value?.$case === "numberValue") {
      obj.numberValue = message.value.numberValue;
    } else if (message.value?.$case === "boolValue") {
      obj.boolValue = message.value.boolValue;
    } else if (message.value?.$case === "nullValue") {
      obj.nullValue = message.value.nullValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LiteralValue>, I>>(base?: I): LiteralValue {
    return LiteralValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiteralValue>, I>>(object: I): LiteralValue {
    const message = createBaseLiteralValue();
    switch (object.value?.$case) {
      case "stringValue": {
        if (object.value?.stringValue !== undefined && object.value?.stringValue !== null) {
          message.value = { $case: "stringValue", stringValue: object.value.stringValue };
        }
        break;
      }
      case "numberValue": {
        if (object.value?.numberValue !== undefined && object.value?.numberValue !== null) {
          message.value = { $case: "numberValue", numberValue: object.value.numberValue };
        }
        break;
      }
      case "boolValue": {
        if (object.value?.boolValue !== undefined && object.value?.boolValue !== null) {
          message.value = { $case: "boolValue", boolValue: object.value.boolValue };
        }
        break;
      }
      case "nullValue": {
        if (object.value?.nullValue !== undefined && object.value?.nullValue !== null) {
          message.value = { $case: "nullValue", nullValue: object.value.nullValue };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseCoalesceSource(): CoalesceSource {
  return { paths: [] };
}

export const CoalesceSource: MessageFns<CoalesceSource> = {
  fromJSON(object: any): CoalesceSource {
    return { paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: CoalesceSource): unknown {
    const obj: any = {};
    if (message.paths?.length) {
      obj.paths = message.paths;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoalesceSource>, I>>(base?: I): CoalesceSource {
    return CoalesceSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoalesceSource>, I>>(object: I): CoalesceSource {
    const message = createBaseCoalesceSource();
    message.paths = object.paths?.map((e) => e) || [];
    return message;
  },
};

function createBaseTemplateSource(): TemplateSource {
  return { template: "", vars: {} };
}

export const TemplateSource: MessageFns<TemplateSource> = {
  fromJSON(object: any): TemplateSource {
    return {
      template: isSet(object.template) ? globalThis.String(object.template) : "",
      vars: isObject(object.vars)
        ? (globalThis.Object.entries(object.vars) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: TemplateSource): unknown {
    const obj: any = {};
    if (message.template !== "") {
      obj.template = message.template;
    }
    if (message.vars) {
      const entries = globalThis.Object.entries(message.vars) as [string, string][];
      if (entries.length > 0) {
        obj.vars = {};
        entries.forEach(([k, v]) => {
          obj.vars[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TemplateSource>, I>>(base?: I): TemplateSource {
    return TemplateSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TemplateSource>, I>>(object: I): TemplateSource {
    const message = createBaseTemplateSource();
    message.template = object.template ?? "";
    message.vars = (globalThis.Object.entries(object.vars ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTemplateSource_VarsEntry(): TemplateSource_VarsEntry {
  return { key: "", value: "" };
}

export const TemplateSource_VarsEntry: MessageFns<TemplateSource_VarsEntry> = {
  fromJSON(object: any): TemplateSource_VarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TemplateSource_VarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TemplateSource_VarsEntry>, I>>(base?: I): TemplateSource_VarsEntry {
    return TemplateSource_VarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TemplateSource_VarsEntry>, I>>(object: I): TemplateSource_VarsEntry {
    const message = createBaseTemplateSource_VarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConcatSource(): ConcatSource {
  return { paths: [], separator: undefined };
}

export const ConcatSource: MessageFns<ConcatSource> = {
  fromJSON(object: any): ConcatSource {
    return {
      paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e: any) => globalThis.String(e)) : [],
      separator: isSet(object.separator) ? globalThis.String(object.separator) : undefined,
    };
  },

  toJSON(message: ConcatSource): unknown {
    const obj: any = {};
    if (message.paths?.length) {
      obj.paths = message.paths;
    }
    if (message.separator !== undefined) {
      obj.separator = message.separator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConcatSource>, I>>(base?: I): ConcatSource {
    return ConcatSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConcatSource>, I>>(object: I): ConcatSource {
    const message = createBaseConcatSource();
    message.paths = object.paths?.map((e) => e) || [];
    message.separator = object.separator ?? undefined;
    return message;
  },
};

function createBaseMapEachSpec(): MapEachSpec {
  return { inner: undefined };
}

export const MapEachSpec: MessageFns<MapEachSpec> = {
  fromJSON(object: any): MapEachSpec {
    return { inner: isSet(object.inner) ? MapEachInner.fromJSON(object.inner) : undefined };
  },

  toJSON(message: MapEachSpec): unknown {
    const obj: any = {};
    if (message.inner !== undefined) {
      obj.inner = MapEachInner.toJSON(message.inner);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapEachSpec>, I>>(base?: I): MapEachSpec {
    return MapEachSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapEachSpec>, I>>(object: I): MapEachSpec {
    const message = createBaseMapEachSpec();
    message.inner = (object.inner !== undefined && object.inner !== null)
      ? MapEachInner.fromPartial(object.inner)
      : undefined;
    return message;
  },
};

function createBaseMapEachInner(): MapEachInner {
  return { inner: undefined };
}

export const MapEachInner: MessageFns<MapEachInner> = {
  fromJSON(object: any): MapEachInner {
    return {
      inner: isSet(object.tool)
        ? { $case: "tool", tool: globalThis.String(object.tool) }
        : isSet(object.pattern)
        ? { $case: "pattern", pattern: PatternSpec.fromJSON(object.pattern) }
        : undefined,
    };
  },

  toJSON(message: MapEachInner): unknown {
    const obj: any = {};
    if (message.inner?.$case === "tool") {
      obj.tool = message.inner.tool;
    } else if (message.inner?.$case === "pattern") {
      obj.pattern = PatternSpec.toJSON(message.inner.pattern);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapEachInner>, I>>(base?: I): MapEachInner {
    return MapEachInner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapEachInner>, I>>(object: I): MapEachInner {
    const message = createBaseMapEachInner();
    switch (object.inner?.$case) {
      case "tool": {
        if (object.inner?.tool !== undefined && object.inner?.tool !== null) {
          message.inner = { $case: "tool", tool: object.inner.tool };
        }
        break;
      }
      case "pattern": {
        if (object.inner?.pattern !== undefined && object.inner?.pattern !== null) {
          message.inner = { $case: "pattern", pattern: PatternSpec.fromPartial(object.inner.pattern) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseOutputTransform(): OutputTransform {
  return { mappings: {} };
}

export const OutputTransform: MessageFns<OutputTransform> = {
  fromJSON(object: any): OutputTransform {
    return {
      mappings: isObject(object.mappings)
        ? (globalThis.Object.entries(object.mappings) as [string, any][]).reduce(
          (acc: { [key: string]: FieldSource }, [key, value]: [string, any]) => {
            acc[key] = FieldSource.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: OutputTransform): unknown {
    const obj: any = {};
    if (message.mappings) {
      const entries = globalThis.Object.entries(message.mappings) as [string, FieldSource][];
      if (entries.length > 0) {
        obj.mappings = {};
        entries.forEach(([k, v]) => {
          obj.mappings[k] = FieldSource.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputTransform>, I>>(base?: I): OutputTransform {
    return OutputTransform.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputTransform>, I>>(object: I): OutputTransform {
    const message = createBaseOutputTransform();
    message.mappings = (globalThis.Object.entries(object.mappings ?? {}) as [string, FieldSource][]).reduce(
      (acc: { [key: string]: FieldSource }, [key, value]: [string, FieldSource]) => {
        if (value !== undefined) {
          acc[key] = FieldSource.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseOutputTransform_MappingsEntry(): OutputTransform_MappingsEntry {
  return { key: "", value: undefined };
}

export const OutputTransform_MappingsEntry: MessageFns<OutputTransform_MappingsEntry> = {
  fromJSON(object: any): OutputTransform_MappingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? FieldSource.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: OutputTransform_MappingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = FieldSource.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputTransform_MappingsEntry>, I>>(base?: I): OutputTransform_MappingsEntry {
    return OutputTransform_MappingsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputTransform_MappingsEntry>, I>>(
    object: I,
  ): OutputTransform_MappingsEntry {
    const message = createBaseOutputTransform_MappingsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? FieldSource.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRetrySpec(): RetrySpec {
  return {
    inner: undefined,
    maxAttempts: 0,
    backoff: undefined,
    retryIf: undefined,
    jitter: undefined,
    attemptTimeoutMs: undefined,
  };
}

export const RetrySpec: MessageFns<RetrySpec> = {
  fromJSON(object: any): RetrySpec {
    return {
      inner: isSet(object.inner) ? StepOperation.fromJSON(object.inner) : undefined,
      maxAttempts: isSet(object.maxAttempts)
        ? globalThis.Number(object.maxAttempts)
        : isSet(object.max_attempts)
        ? globalThis.Number(object.max_attempts)
        : 0,
      backoff: isSet(object.backoff) ? BackoffStrategy.fromJSON(object.backoff) : undefined,
      retryIf: isSet(object.retryIf)
        ? FieldPredicate.fromJSON(object.retryIf)
        : isSet(object.retry_if)
        ? FieldPredicate.fromJSON(object.retry_if)
        : undefined,
      jitter: isSet(object.jitter) ? globalThis.Number(object.jitter) : undefined,
      attemptTimeoutMs: isSet(object.attemptTimeoutMs)
        ? globalThis.Number(object.attemptTimeoutMs)
        : isSet(object.attempt_timeout_ms)
        ? globalThis.Number(object.attempt_timeout_ms)
        : undefined,
    };
  },

  toJSON(message: RetrySpec): unknown {
    const obj: any = {};
    if (message.inner !== undefined) {
      obj.inner = StepOperation.toJSON(message.inner);
    }
    if (message.maxAttempts !== 0) {
      obj.maxAttempts = Math.round(message.maxAttempts);
    }
    if (message.backoff !== undefined) {
      obj.backoff = BackoffStrategy.toJSON(message.backoff);
    }
    if (message.retryIf !== undefined) {
      obj.retryIf = FieldPredicate.toJSON(message.retryIf);
    }
    if (message.jitter !== undefined) {
      obj.jitter = message.jitter;
    }
    if (message.attemptTimeoutMs !== undefined) {
      obj.attemptTimeoutMs = Math.round(message.attemptTimeoutMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetrySpec>, I>>(base?: I): RetrySpec {
    return RetrySpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetrySpec>, I>>(object: I): RetrySpec {
    const message = createBaseRetrySpec();
    message.inner = (object.inner !== undefined && object.inner !== null)
      ? StepOperation.fromPartial(object.inner)
      : undefined;
    message.maxAttempts = object.maxAttempts ?? 0;
    message.backoff = (object.backoff !== undefined && object.backoff !== null)
      ? BackoffStrategy.fromPartial(object.backoff)
      : undefined;
    message.retryIf = (object.retryIf !== undefined && object.retryIf !== null)
      ? FieldPredicate.fromPartial(object.retryIf)
      : undefined;
    message.jitter = object.jitter ?? undefined;
    message.attemptTimeoutMs = object.attemptTimeoutMs ?? undefined;
    return message;
  },
};

function createBaseBackoffStrategy(): BackoffStrategy {
  return { strategy: undefined };
}

export const BackoffStrategy: MessageFns<BackoffStrategy> = {
  fromJSON(object: any): BackoffStrategy {
    return {
      strategy: isSet(object.fixed)
        ? { $case: "fixed", fixed: FixedBackoff.fromJSON(object.fixed) }
        : isSet(object.exponential)
        ? { $case: "exponential", exponential: ExponentialBackoff.fromJSON(object.exponential) }
        : isSet(object.linear)
        ? { $case: "linear", linear: LinearBackoff.fromJSON(object.linear) }
        : undefined,
    };
  },

  toJSON(message: BackoffStrategy): unknown {
    const obj: any = {};
    if (message.strategy?.$case === "fixed") {
      obj.fixed = FixedBackoff.toJSON(message.strategy.fixed);
    } else if (message.strategy?.$case === "exponential") {
      obj.exponential = ExponentialBackoff.toJSON(message.strategy.exponential);
    } else if (message.strategy?.$case === "linear") {
      obj.linear = LinearBackoff.toJSON(message.strategy.linear);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackoffStrategy>, I>>(base?: I): BackoffStrategy {
    return BackoffStrategy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackoffStrategy>, I>>(object: I): BackoffStrategy {
    const message = createBaseBackoffStrategy();
    switch (object.strategy?.$case) {
      case "fixed": {
        if (object.strategy?.fixed !== undefined && object.strategy?.fixed !== null) {
          message.strategy = { $case: "fixed", fixed: FixedBackoff.fromPartial(object.strategy.fixed) };
        }
        break;
      }
      case "exponential": {
        if (object.strategy?.exponential !== undefined && object.strategy?.exponential !== null) {
          message.strategy = {
            $case: "exponential",
            exponential: ExponentialBackoff.fromPartial(object.strategy.exponential),
          };
        }
        break;
      }
      case "linear": {
        if (object.strategy?.linear !== undefined && object.strategy?.linear !== null) {
          message.strategy = { $case: "linear", linear: LinearBackoff.fromPartial(object.strategy.linear) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseFixedBackoff(): FixedBackoff {
  return { delayMs: 0 };
}

export const FixedBackoff: MessageFns<FixedBackoff> = {
  fromJSON(object: any): FixedBackoff {
    return {
      delayMs: isSet(object.delayMs)
        ? globalThis.Number(object.delayMs)
        : isSet(object.delay_ms)
        ? globalThis.Number(object.delay_ms)
        : 0,
    };
  },

  toJSON(message: FixedBackoff): unknown {
    const obj: any = {};
    if (message.delayMs !== 0) {
      obj.delayMs = Math.round(message.delayMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FixedBackoff>, I>>(base?: I): FixedBackoff {
    return FixedBackoff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FixedBackoff>, I>>(object: I): FixedBackoff {
    const message = createBaseFixedBackoff();
    message.delayMs = object.delayMs ?? 0;
    return message;
  },
};

function createBaseExponentialBackoff(): ExponentialBackoff {
  return { initialDelayMs: 0, maxDelayMs: 0, multiplier: undefined };
}

export const ExponentialBackoff: MessageFns<ExponentialBackoff> = {
  fromJSON(object: any): ExponentialBackoff {
    return {
      initialDelayMs: isSet(object.initialDelayMs)
        ? globalThis.Number(object.initialDelayMs)
        : isSet(object.initial_delay_ms)
        ? globalThis.Number(object.initial_delay_ms)
        : 0,
      maxDelayMs: isSet(object.maxDelayMs)
        ? globalThis.Number(object.maxDelayMs)
        : isSet(object.max_delay_ms)
        ? globalThis.Number(object.max_delay_ms)
        : 0,
      multiplier: isSet(object.multiplier) ? globalThis.Number(object.multiplier) : undefined,
    };
  },

  toJSON(message: ExponentialBackoff): unknown {
    const obj: any = {};
    if (message.initialDelayMs !== 0) {
      obj.initialDelayMs = Math.round(message.initialDelayMs);
    }
    if (message.maxDelayMs !== 0) {
      obj.maxDelayMs = Math.round(message.maxDelayMs);
    }
    if (message.multiplier !== undefined) {
      obj.multiplier = message.multiplier;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExponentialBackoff>, I>>(base?: I): ExponentialBackoff {
    return ExponentialBackoff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExponentialBackoff>, I>>(object: I): ExponentialBackoff {
    const message = createBaseExponentialBackoff();
    message.initialDelayMs = object.initialDelayMs ?? 0;
    message.maxDelayMs = object.maxDelayMs ?? 0;
    message.multiplier = object.multiplier ?? undefined;
    return message;
  },
};

function createBaseLinearBackoff(): LinearBackoff {
  return { initialDelayMs: 0, incrementMs: 0, maxDelayMs: 0 };
}

export const LinearBackoff: MessageFns<LinearBackoff> = {
  fromJSON(object: any): LinearBackoff {
    return {
      initialDelayMs: isSet(object.initialDelayMs)
        ? globalThis.Number(object.initialDelayMs)
        : isSet(object.initial_delay_ms)
        ? globalThis.Number(object.initial_delay_ms)
        : 0,
      incrementMs: isSet(object.incrementMs)
        ? globalThis.Number(object.incrementMs)
        : isSet(object.increment_ms)
        ? globalThis.Number(object.increment_ms)
        : 0,
      maxDelayMs: isSet(object.maxDelayMs)
        ? globalThis.Number(object.maxDelayMs)
        : isSet(object.max_delay_ms)
        ? globalThis.Number(object.max_delay_ms)
        : 0,
    };
  },

  toJSON(message: LinearBackoff): unknown {
    const obj: any = {};
    if (message.initialDelayMs !== 0) {
      obj.initialDelayMs = Math.round(message.initialDelayMs);
    }
    if (message.incrementMs !== 0) {
      obj.incrementMs = Math.round(message.incrementMs);
    }
    if (message.maxDelayMs !== 0) {
      obj.maxDelayMs = Math.round(message.maxDelayMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinearBackoff>, I>>(base?: I): LinearBackoff {
    return LinearBackoff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinearBackoff>, I>>(object: I): LinearBackoff {
    const message = createBaseLinearBackoff();
    message.initialDelayMs = object.initialDelayMs ?? 0;
    message.incrementMs = object.incrementMs ?? 0;
    message.maxDelayMs = object.maxDelayMs ?? 0;
    return message;
  },
};

function createBaseTimeoutSpec(): TimeoutSpec {
  return { inner: undefined, durationMs: 0, fallback: undefined, message: undefined };
}

export const TimeoutSpec: MessageFns<TimeoutSpec> = {
  fromJSON(object: any): TimeoutSpec {
    return {
      inner: isSet(object.inner) ? StepOperation.fromJSON(object.inner) : undefined,
      durationMs: isSet(object.durationMs)
        ? globalThis.Number(object.durationMs)
        : isSet(object.duration_ms)
        ? globalThis.Number(object.duration_ms)
        : 0,
      fallback: isSet(object.fallback) ? StepOperation.fromJSON(object.fallback) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: TimeoutSpec): unknown {
    const obj: any = {};
    if (message.inner !== undefined) {
      obj.inner = StepOperation.toJSON(message.inner);
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    if (message.fallback !== undefined) {
      obj.fallback = StepOperation.toJSON(message.fallback);
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeoutSpec>, I>>(base?: I): TimeoutSpec {
    return TimeoutSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeoutSpec>, I>>(object: I): TimeoutSpec {
    const message = createBaseTimeoutSpec();
    message.inner = (object.inner !== undefined && object.inner !== null)
      ? StepOperation.fromPartial(object.inner)
      : undefined;
    message.durationMs = object.durationMs ?? 0;
    message.fallback = (object.fallback !== undefined && object.fallback !== null)
      ? StepOperation.fromPartial(object.fallback)
      : undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseCacheSpec(): CacheSpec {
  return {
    keyPaths: [],
    inner: undefined,
    store: "",
    ttlSeconds: 0,
    staleWhileRevalidateSeconds: undefined,
    cacheIf: undefined,
  };
}

export const CacheSpec: MessageFns<CacheSpec> = {
  fromJSON(object: any): CacheSpec {
    return {
      keyPaths: globalThis.Array.isArray(object?.keyPaths)
        ? object.keyPaths.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.key_paths)
        ? object.key_paths.map((e: any) => globalThis.String(e))
        : [],
      inner: isSet(object.inner) ? StepOperation.fromJSON(object.inner) : undefined,
      store: isSet(object.store) ? globalThis.String(object.store) : "",
      ttlSeconds: isSet(object.ttlSeconds)
        ? globalThis.Number(object.ttlSeconds)
        : isSet(object.ttl_seconds)
        ? globalThis.Number(object.ttl_seconds)
        : 0,
      staleWhileRevalidateSeconds: isSet(object.staleWhileRevalidateSeconds)
        ? globalThis.Number(object.staleWhileRevalidateSeconds)
        : isSet(object.stale_while_revalidate_seconds)
        ? globalThis.Number(object.stale_while_revalidate_seconds)
        : undefined,
      cacheIf: isSet(object.cacheIf)
        ? FieldPredicate.fromJSON(object.cacheIf)
        : isSet(object.cache_if)
        ? FieldPredicate.fromJSON(object.cache_if)
        : undefined,
    };
  },

  toJSON(message: CacheSpec): unknown {
    const obj: any = {};
    if (message.keyPaths?.length) {
      obj.keyPaths = message.keyPaths;
    }
    if (message.inner !== undefined) {
      obj.inner = StepOperation.toJSON(message.inner);
    }
    if (message.store !== "") {
      obj.store = message.store;
    }
    if (message.ttlSeconds !== 0) {
      obj.ttlSeconds = Math.round(message.ttlSeconds);
    }
    if (message.staleWhileRevalidateSeconds !== undefined) {
      obj.staleWhileRevalidateSeconds = Math.round(message.staleWhileRevalidateSeconds);
    }
    if (message.cacheIf !== undefined) {
      obj.cacheIf = FieldPredicate.toJSON(message.cacheIf);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CacheSpec>, I>>(base?: I): CacheSpec {
    return CacheSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CacheSpec>, I>>(object: I): CacheSpec {
    const message = createBaseCacheSpec();
    message.keyPaths = object.keyPaths?.map((e) => e) || [];
    message.inner = (object.inner !== undefined && object.inner !== null)
      ? StepOperation.fromPartial(object.inner)
      : undefined;
    message.store = object.store ?? "";
    message.ttlSeconds = object.ttlSeconds ?? 0;
    message.staleWhileRevalidateSeconds = object.staleWhileRevalidateSeconds ?? undefined;
    message.cacheIf = (object.cacheIf !== undefined && object.cacheIf !== null)
      ? FieldPredicate.fromPartial(object.cacheIf)
      : undefined;
    return message;
  },
};

function createBaseIdempotentSpec(): IdempotentSpec {
  return {
    keyPaths: [],
    inner: undefined,
    store: "",
    ttlSeconds: undefined,
    onDuplicate: OnDuplicate.ON_DUPLICATE_UNSPECIFIED,
  };
}

export const IdempotentSpec: MessageFns<IdempotentSpec> = {
  fromJSON(object: any): IdempotentSpec {
    return {
      keyPaths: globalThis.Array.isArray(object?.keyPaths)
        ? object.keyPaths.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.key_paths)
        ? object.key_paths.map((e: any) => globalThis.String(e))
        : [],
      inner: isSet(object.inner) ? StepOperation.fromJSON(object.inner) : undefined,
      store: isSet(object.store) ? globalThis.String(object.store) : "",
      ttlSeconds: isSet(object.ttlSeconds)
        ? globalThis.Number(object.ttlSeconds)
        : isSet(object.ttl_seconds)
        ? globalThis.Number(object.ttl_seconds)
        : undefined,
      onDuplicate: isSet(object.onDuplicate)
        ? onDuplicateFromJSON(object.onDuplicate)
        : isSet(object.on_duplicate)
        ? onDuplicateFromJSON(object.on_duplicate)
        : OnDuplicate.ON_DUPLICATE_UNSPECIFIED,
    };
  },

  toJSON(message: IdempotentSpec): unknown {
    const obj: any = {};
    if (message.keyPaths?.length) {
      obj.keyPaths = message.keyPaths;
    }
    if (message.inner !== undefined) {
      obj.inner = StepOperation.toJSON(message.inner);
    }
    if (message.store !== "") {
      obj.store = message.store;
    }
    if (message.ttlSeconds !== undefined) {
      obj.ttlSeconds = Math.round(message.ttlSeconds);
    }
    if (message.onDuplicate !== OnDuplicate.ON_DUPLICATE_UNSPECIFIED) {
      obj.onDuplicate = onDuplicateToJSON(message.onDuplicate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdempotentSpec>, I>>(base?: I): IdempotentSpec {
    return IdempotentSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdempotentSpec>, I>>(object: I): IdempotentSpec {
    const message = createBaseIdempotentSpec();
    message.keyPaths = object.keyPaths?.map((e) => e) || [];
    message.inner = (object.inner !== undefined && object.inner !== null)
      ? StepOperation.fromPartial(object.inner)
      : undefined;
    message.store = object.store ?? "";
    message.ttlSeconds = object.ttlSeconds ?? undefined;
    message.onDuplicate = object.onDuplicate ?? OnDuplicate.ON_DUPLICATE_UNSPECIFIED;
    return message;
  },
};

function createBaseCircuitBreakerSpec(): CircuitBreakerSpec {
  return {
    name: "",
    inner: undefined,
    store: "",
    failureThreshold: 0,
    failureWindowSeconds: 0,
    resetTimeoutSeconds: 0,
    successThreshold: undefined,
    fallback: undefined,
    failureIf: undefined,
  };
}

export const CircuitBreakerSpec: MessageFns<CircuitBreakerSpec> = {
  fromJSON(object: any): CircuitBreakerSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      inner: isSet(object.inner) ? StepOperation.fromJSON(object.inner) : undefined,
      store: isSet(object.store) ? globalThis.String(object.store) : "",
      failureThreshold: isSet(object.failureThreshold)
        ? globalThis.Number(object.failureThreshold)
        : isSet(object.failure_threshold)
        ? globalThis.Number(object.failure_threshold)
        : 0,
      failureWindowSeconds: isSet(object.failureWindowSeconds)
        ? globalThis.Number(object.failureWindowSeconds)
        : isSet(object.failure_window_seconds)
        ? globalThis.Number(object.failure_window_seconds)
        : 0,
      resetTimeoutSeconds: isSet(object.resetTimeoutSeconds)
        ? globalThis.Number(object.resetTimeoutSeconds)
        : isSet(object.reset_timeout_seconds)
        ? globalThis.Number(object.reset_timeout_seconds)
        : 0,
      successThreshold: isSet(object.successThreshold)
        ? globalThis.Number(object.successThreshold)
        : isSet(object.success_threshold)
        ? globalThis.Number(object.success_threshold)
        : undefined,
      fallback: isSet(object.fallback) ? StepOperation.fromJSON(object.fallback) : undefined,
      failureIf: isSet(object.failureIf)
        ? FieldPredicate.fromJSON(object.failureIf)
        : isSet(object.failure_if)
        ? FieldPredicate.fromJSON(object.failure_if)
        : undefined,
    };
  },

  toJSON(message: CircuitBreakerSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.inner !== undefined) {
      obj.inner = StepOperation.toJSON(message.inner);
    }
    if (message.store !== "") {
      obj.store = message.store;
    }
    if (message.failureThreshold !== 0) {
      obj.failureThreshold = Math.round(message.failureThreshold);
    }
    if (message.failureWindowSeconds !== 0) {
      obj.failureWindowSeconds = Math.round(message.failureWindowSeconds);
    }
    if (message.resetTimeoutSeconds !== 0) {
      obj.resetTimeoutSeconds = Math.round(message.resetTimeoutSeconds);
    }
    if (message.successThreshold !== undefined) {
      obj.successThreshold = Math.round(message.successThreshold);
    }
    if (message.fallback !== undefined) {
      obj.fallback = StepOperation.toJSON(message.fallback);
    }
    if (message.failureIf !== undefined) {
      obj.failureIf = FieldPredicate.toJSON(message.failureIf);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CircuitBreakerSpec>, I>>(base?: I): CircuitBreakerSpec {
    return CircuitBreakerSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CircuitBreakerSpec>, I>>(object: I): CircuitBreakerSpec {
    const message = createBaseCircuitBreakerSpec();
    message.name = object.name ?? "";
    message.inner = (object.inner !== undefined && object.inner !== null)
      ? StepOperation.fromPartial(object.inner)
      : undefined;
    message.store = object.store ?? "";
    message.failureThreshold = object.failureThreshold ?? 0;
    message.failureWindowSeconds = object.failureWindowSeconds ?? 0;
    message.resetTimeoutSeconds = object.resetTimeoutSeconds ?? 0;
    message.successThreshold = object.successThreshold ?? undefined;
    message.fallback = (object.fallback !== undefined && object.fallback !== null)
      ? StepOperation.fromPartial(object.fallback)
      : undefined;
    message.failureIf = (object.failureIf !== undefined && object.failureIf !== null)
      ? FieldPredicate.fromPartial(object.failureIf)
      : undefined;
    return message;
  },
};

function createBaseDeadLetterSpec(): DeadLetterSpec {
  return { inner: undefined, deadLetterTool: "", maxAttempts: undefined, backoff: undefined, rethrow: false };
}

export const DeadLetterSpec: MessageFns<DeadLetterSpec> = {
  fromJSON(object: any): DeadLetterSpec {
    return {
      inner: isSet(object.inner) ? StepOperation.fromJSON(object.inner) : undefined,
      deadLetterTool: isSet(object.deadLetterTool)
        ? globalThis.String(object.deadLetterTool)
        : isSet(object.dead_letter_tool)
        ? globalThis.String(object.dead_letter_tool)
        : "",
      maxAttempts: isSet(object.maxAttempts)
        ? globalThis.Number(object.maxAttempts)
        : isSet(object.max_attempts)
        ? globalThis.Number(object.max_attempts)
        : undefined,
      backoff: isSet(object.backoff) ? BackoffStrategy.fromJSON(object.backoff) : undefined,
      rethrow: isSet(object.rethrow) ? globalThis.Boolean(object.rethrow) : false,
    };
  },

  toJSON(message: DeadLetterSpec): unknown {
    const obj: any = {};
    if (message.inner !== undefined) {
      obj.inner = StepOperation.toJSON(message.inner);
    }
    if (message.deadLetterTool !== "") {
      obj.deadLetterTool = message.deadLetterTool;
    }
    if (message.maxAttempts !== undefined) {
      obj.maxAttempts = Math.round(message.maxAttempts);
    }
    if (message.backoff !== undefined) {
      obj.backoff = BackoffStrategy.toJSON(message.backoff);
    }
    if (message.rethrow !== false) {
      obj.rethrow = message.rethrow;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeadLetterSpec>, I>>(base?: I): DeadLetterSpec {
    return DeadLetterSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeadLetterSpec>, I>>(object: I): DeadLetterSpec {
    const message = createBaseDeadLetterSpec();
    message.inner = (object.inner !== undefined && object.inner !== null)
      ? StepOperation.fromPartial(object.inner)
      : undefined;
    message.deadLetterTool = object.deadLetterTool ?? "";
    message.maxAttempts = object.maxAttempts ?? undefined;
    message.backoff = (object.backoff !== undefined && object.backoff !== null)
      ? BackoffStrategy.fromPartial(object.backoff)
      : undefined;
    message.rethrow = object.rethrow ?? false;
    return message;
  },
};

function createBaseSagaSpec(): SagaSpec {
  return { steps: [], store: undefined, sagaIdPath: undefined, timeoutMs: undefined, output: undefined };
}

export const SagaSpec: MessageFns<SagaSpec> = {
  fromJSON(object: any): SagaSpec {
    return {
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => SagaStep.fromJSON(e)) : [],
      store: isSet(object.store) ? globalThis.String(object.store) : undefined,
      sagaIdPath: isSet(object.sagaIdPath)
        ? globalThis.String(object.sagaIdPath)
        : isSet(object.saga_id_path)
        ? globalThis.String(object.saga_id_path)
        : undefined,
      timeoutMs: isSet(object.timeoutMs)
        ? globalThis.Number(object.timeoutMs)
        : isSet(object.timeout_ms)
        ? globalThis.Number(object.timeout_ms)
        : undefined,
      output: isSet(object.output) ? DataBinding.fromJSON(object.output) : undefined,
    };
  },

  toJSON(message: SagaSpec): unknown {
    const obj: any = {};
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => SagaStep.toJSON(e));
    }
    if (message.store !== undefined) {
      obj.store = message.store;
    }
    if (message.sagaIdPath !== undefined) {
      obj.sagaIdPath = message.sagaIdPath;
    }
    if (message.timeoutMs !== undefined) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    if (message.output !== undefined) {
      obj.output = DataBinding.toJSON(message.output);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SagaSpec>, I>>(base?: I): SagaSpec {
    return SagaSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SagaSpec>, I>>(object: I): SagaSpec {
    const message = createBaseSagaSpec();
    message.steps = object.steps?.map((e) => SagaStep.fromPartial(e)) || [];
    message.store = object.store ?? undefined;
    message.sagaIdPath = object.sagaIdPath ?? undefined;
    message.timeoutMs = object.timeoutMs ?? undefined;
    message.output = (object.output !== undefined && object.output !== null)
      ? DataBinding.fromPartial(object.output)
      : undefined;
    return message;
  },
};

function createBaseSagaStep(): SagaStep {
  return { id: "", name: "", action: undefined, compensate: undefined, input: undefined };
}

export const SagaStep: MessageFns<SagaStep> = {
  fromJSON(object: any): SagaStep {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      action: isSet(object.action) ? StepOperation.fromJSON(object.action) : undefined,
      compensate: isSet(object.compensate) ? StepOperation.fromJSON(object.compensate) : undefined,
      input: isSet(object.input) ? DataBinding.fromJSON(object.input) : undefined,
    };
  },

  toJSON(message: SagaStep): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.action !== undefined) {
      obj.action = StepOperation.toJSON(message.action);
    }
    if (message.compensate !== undefined) {
      obj.compensate = StepOperation.toJSON(message.compensate);
    }
    if (message.input !== undefined) {
      obj.input = DataBinding.toJSON(message.input);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SagaStep>, I>>(base?: I): SagaStep {
    return SagaStep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SagaStep>, I>>(object: I): SagaStep {
    const message = createBaseSagaStep();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.action = (object.action !== undefined && object.action !== null)
      ? StepOperation.fromPartial(object.action)
      : undefined;
    message.compensate = (object.compensate !== undefined && object.compensate !== null)
      ? StepOperation.fromPartial(object.compensate)
      : undefined;
    message.input = (object.input !== undefined && object.input !== null)
      ? DataBinding.fromPartial(object.input)
      : undefined;
    return message;
  },
};

function createBaseClaimCheckSpec(): ClaimCheckSpec {
  return { storeTool: "", retrieveTool: "", inner: undefined, retrieveAtEnd: false };
}

export const ClaimCheckSpec: MessageFns<ClaimCheckSpec> = {
  fromJSON(object: any): ClaimCheckSpec {
    return {
      storeTool: isSet(object.storeTool)
        ? globalThis.String(object.storeTool)
        : isSet(object.store_tool)
        ? globalThis.String(object.store_tool)
        : "",
      retrieveTool: isSet(object.retrieveTool)
        ? globalThis.String(object.retrieveTool)
        : isSet(object.retrieve_tool)
        ? globalThis.String(object.retrieve_tool)
        : "",
      inner: isSet(object.inner) ? StepOperation.fromJSON(object.inner) : undefined,
      retrieveAtEnd: isSet(object.retrieveAtEnd)
        ? globalThis.Boolean(object.retrieveAtEnd)
        : isSet(object.retrieve_at_end)
        ? globalThis.Boolean(object.retrieve_at_end)
        : false,
    };
  },

  toJSON(message: ClaimCheckSpec): unknown {
    const obj: any = {};
    if (message.storeTool !== "") {
      obj.storeTool = message.storeTool;
    }
    if (message.retrieveTool !== "") {
      obj.retrieveTool = message.retrieveTool;
    }
    if (message.inner !== undefined) {
      obj.inner = StepOperation.toJSON(message.inner);
    }
    if (message.retrieveAtEnd !== false) {
      obj.retrieveAtEnd = message.retrieveAtEnd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimCheckSpec>, I>>(base?: I): ClaimCheckSpec {
    return ClaimCheckSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimCheckSpec>, I>>(object: I): ClaimCheckSpec {
    const message = createBaseClaimCheckSpec();
    message.storeTool = object.storeTool ?? "";
    message.retrieveTool = object.retrieveTool ?? "";
    message.inner = (object.inner !== undefined && object.inner !== null)
      ? StepOperation.fromPartial(object.inner)
      : undefined;
    message.retrieveAtEnd = object.retrieveAtEnd ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
