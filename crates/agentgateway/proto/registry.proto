syntax = "proto3";

package agentgateway.dev.registry;

import "google/protobuf/struct.proto";

option go_package = "github.com/agentgateway/agentgateway/go/api;api";

// Registry is the root container for tool definitions
message Registry {
  // Schema version for compatibility checking
  string schema_version = 1;
  
  // List of tool definitions (virtual tools and compositions)
  repeated ToolDefinition tools = 2;
}

// ToolDefinition represents either a virtual tool (1:1 mapping) or a composition (N:1 orchestration)
message ToolDefinition {
  // Name exposed to agents (unique identifier)
  string name = 1;
  
  // Optional description (for source-based, can inherit from backend)
  optional string description = 2;
  
  // Tool implementation - either source-based or composition
  oneof implementation {
    // Virtual tool: adapts a single backend tool (1:1)
    SourceTool source = 3;
    
    // Composition: orchestrates multiple tools (N:1)
    PatternSpec spec = 4;
  }
  
  // Input schema override (JSON Schema as struct)
  optional google.protobuf.Struct input_schema = 5;
  
  // Output transformation (applies to both virtual tools and compositions)
  optional OutputTransform output_transform = 6;
  
  // Semantic version of this tool definition
  optional string version = 7;
  
  // Arbitrary metadata (owner, classification, etc.)
  map<string, google.protobuf.Value> metadata = 8;
}

// SourceTool defines a 1:1 mapping to a backend tool
message SourceTool {
  // Target name (MCP server/backend name)
  string target = 1;
  
  // Original tool name on that target
  string tool = 2;
  
  // Fields to inject at call time (supports ${ENV_VAR} substitution)
  map<string, google.protobuf.Value> defaults = 3;
  
  // Fields to remove from schema (hidden from agents)
  repeated string hide_fields = 4;
}

// PatternSpec defines a composition pattern
message PatternSpec {
  oneof pattern {
    // Stateless patterns (implemented)
    PipelineSpec pipeline = 1;
    ScatterGatherSpec scatter_gather = 2;
    FilterSpec filter = 3;
    SchemaMapSpec schema_map = 4;
    MapEachSpec map_each = 5;

    // Stateful patterns (IR defined, runtime not yet implemented)
    RetrySpec retry = 20;
    TimeoutSpec timeout = 21;
    CacheSpec cache = 22;
    IdempotentSpec idempotent = 23;
    CircuitBreakerSpec circuit_breaker = 24;
    DeadLetterSpec dead_letter = 25;
    SagaSpec saga = 26;
    ClaimCheckSpec claim_check = 27;
  }
}

// =============================================================================
// Pipeline Pattern
// =============================================================================

// PipelineSpec executes steps sequentially, passing output to next step
message PipelineSpec {
  repeated PipelineStep steps = 1;
}

message PipelineStep {
  // Unique identifier for this step (for data binding references)
  string id = 1;
  
  // The operation to execute
  StepOperation operation = 2;
  
  // Input binding for this step
  DataBinding input = 3;
}

// StepOperation defines what a step does
message StepOperation {
  oneof op {
    // Call a tool by name (resolved from registry or backend)
    ToolCall tool = 1;
    
    // Inline pattern (no separate name)
    PatternSpec pattern = 2;
  }
}

message ToolCall {
  // Tool name (can be virtual tool, composition, or backend tool)
  string name = 1;
}

// DataBinding specifies where step input comes from
message DataBinding {
  oneof source {
    // From composition input
    InputBinding input = 1;
    
    // From a previous step's output
    StepBinding step = 2;
    
    // Constant value
    google.protobuf.Value constant = 3;
  }
}

message InputBinding {
  // JSONPath into composition input (e.g., "$" for whole input, "$.query" for field)
  string path = 1;
}

message StepBinding {
  // ID of the step to reference
  string step_id = 1;
  
  // JSONPath into step output
  string path = 2;
}

// =============================================================================
// Scatter-Gather Pattern
// =============================================================================

// ScatterGatherSpec fans out to multiple targets in parallel and aggregates results
message ScatterGatherSpec {
  // Targets to invoke in parallel
  repeated ScatterTarget targets = 1;
  
  // How to aggregate results
  AggregationStrategy aggregation = 2;
  
  // Timeout in milliseconds (optional)
  optional uint32 timeout_ms = 3;
  
  // If true, fail immediately on first error; if false, collect partial results
  bool fail_fast = 4;
}

message ScatterTarget {
  oneof target {
    // Tool name (resolved from registry or backend)
    string tool = 1;
    
    // Inline pattern
    PatternSpec pattern = 2;
  }
}

// AggregationStrategy defines how to combine scatter-gather results
message AggregationStrategy {
  // Sequence of operations applied in order
  repeated AggregationOp ops = 1;
}

message AggregationOp {
  oneof op {
    // Flatten array of arrays into single array
    bool flatten = 1;
    
    // Sort by field
    SortOp sort = 2;
    
    // Deduplicate by field
    DedupeOp dedupe = 3;
    
    // Take first N results
    LimitOp limit = 4;
    
    // Keep arrays nested (no flattening)
    bool concat = 5;
    
    // Merge objects (for object results)
    bool merge = 6;
  }
}

message SortOp {
  // JSONPath to the field to sort by
  string field = 1;
  
  // Sort order: "asc" or "desc"
  string order = 2;
}

message DedupeOp {
  // JSONPath to the field to dedupe by
  string field = 1;
}

message LimitOp {
  // Maximum number of results
  uint32 count = 1;
}

// =============================================================================
// Filter Pattern
// =============================================================================

// FilterSpec filters array elements based on a predicate
message FilterSpec {
  // The predicate to evaluate for each element
  FieldPredicate predicate = 1;
}

message FieldPredicate {
  // JSONPath to the field to evaluate
  string field = 1;
  
  // Comparison operator: "eq", "ne", "gt", "gte", "lt", "lte", "contains", "in"
  string op = 2;
  
  // Value to compare against
  PredicateValue value = 3;
}

message PredicateValue {
  oneof value {
    string string_value = 1;
    double number_value = 2;
    bool bool_value = 3;
    bool null_value = 4;  // If true, represents null
    ValueList list_value = 5;  // For "in" operator
  }
}

message ValueList {
  repeated PredicateValue values = 1;
}

// =============================================================================
// Schema Map Pattern
// =============================================================================

// SchemaMapSpec transforms input to output using field mappings
message SchemaMapSpec {
  // Field name -> source mapping
  map<string, FieldSource> mappings = 1;
}

message FieldSource {
  oneof source {
    // JSONPath extraction from input
    string path = 1;
    
    // Constant value
    LiteralValue literal = 2;
    
    // First non-null from multiple paths
    CoalesceSource coalesce = 3;
    
    // String template with variable substitution
    TemplateSource template = 4;
    
    // Concatenate multiple fields
    ConcatSource concat = 5;
    
    // Nested object mapping
    SchemaMapSpec nested = 6;
  }
}

message LiteralValue {
  oneof value {
    string string_value = 1;
    double number_value = 2;
    bool bool_value = 3;
    bool null_value = 4;  // If true, value is null
  }
}

message CoalesceSource {
  // JSONPaths to try in order, returning first non-null
  repeated string paths = 1;
}

message TemplateSource {
  // Template string with {var} placeholders
  string template = 1;
  
  // Variable name -> JSONPath binding
  map<string, string> vars = 2;
}

message ConcatSource {
  // JSONPaths to concatenate
  repeated string paths = 1;
  
  // Separator between values (default: empty string)
  optional string separator = 2;
}

// =============================================================================
// Map Each Pattern
// =============================================================================

// MapEachSpec applies an operation to each element of an array
message MapEachSpec {
  // The operation to apply to each element
  MapEachInner inner = 1;
}

message MapEachInner {
  oneof inner {
    // Tool name to call for each element
    string tool = 1;
    
    // Pattern to apply for each element
    PatternSpec pattern = 2;
  }
}

// =============================================================================
// Output Transform
// =============================================================================

// OutputTransform defines how to transform tool/composition output
// This is the unified, enhanced version supporting all mapping features
message OutputTransform {
  // Field name -> source mapping
  map<string, FieldSource> mappings = 1;
}

// =============================================================================
// Stateful Patterns (IR defined, runtime not yet implemented)
// =============================================================================

// RetrySpec - retry with configurable backoff on failure
message RetrySpec {
  // The operation to retry
  StepOperation inner = 1;

  // Maximum attempts (including initial)
  uint32 max_attempts = 2;

  // Backoff strategy
  BackoffStrategy backoff = 3;

  // Condition to retry (if absent, retry all errors)
  optional FieldPredicate retry_if = 4;

  // Jitter factor (0.0 - 1.0)
  optional float jitter = 5;

  // Per-attempt timeout in milliseconds
  optional uint32 attempt_timeout_ms = 6;
}

message BackoffStrategy {
  oneof strategy {
    FixedBackoff fixed = 1;
    ExponentialBackoff exponential = 2;
    LinearBackoff linear = 3;
  }
}

message FixedBackoff {
  uint32 delay_ms = 1;
}

message ExponentialBackoff {
  uint32 initial_delay_ms = 1;
  uint32 max_delay_ms = 2;
  optional float multiplier = 3;  // Default: 2.0
}

message LinearBackoff {
  uint32 initial_delay_ms = 1;
  uint32 increment_ms = 2;
  uint32 max_delay_ms = 3;
}

// TimeoutSpec - enforce maximum execution duration
message TimeoutSpec {
  // The operation to wrap
  StepOperation inner = 1;

  // Timeout duration in milliseconds
  uint32 duration_ms = 2;

  // Fallback on timeout (optional)
  optional StepOperation fallback = 3;

  // Custom error message
  optional string message = 4;
}

// CacheSpec - read-through caching with TTL
message CacheSpec {
  // JSONPath expressions to derive cache key
  repeated string key_paths = 1;

  // The operation to cache
  StepOperation inner = 2;

  // Store reference name (configured in gateway)
  string store = 3;

  // TTL in seconds
  uint32 ttl_seconds = 4;

  // Stale-while-revalidate window in seconds
  optional uint32 stale_while_revalidate_seconds = 5;

  // Condition to cache result (if absent, always cache)
  optional FieldPredicate cache_if = 6;
}

// IdempotentSpec - prevent duplicate processing
message IdempotentSpec {
  // JSONPath expressions to derive idempotency key
  repeated string key_paths = 1;

  // The operation to wrap
  StepOperation inner = 2;

  // Store reference name (configured in gateway)
  string store = 3;

  // TTL in seconds (0 = no expiry)
  optional uint32 ttl_seconds = 4;

  // Behavior on duplicate
  OnDuplicate on_duplicate = 5;
}

enum OnDuplicate {
  ON_DUPLICATE_UNSPECIFIED = 0;
  ON_DUPLICATE_CACHED = 1;   // Return cached result
  ON_DUPLICATE_SKIP = 2;     // Return null/empty
  ON_DUPLICATE_ERROR = 3;    // Return error
}

// CircuitBreakerSpec - fail fast with automatic recovery
message CircuitBreakerSpec {
  // Unique name for this circuit (for state isolation)
  string name = 1;

  // The protected operation
  StepOperation inner = 2;

  // Store for circuit state
  string store = 3;

  // Number of failures to trip the circuit
  uint32 failure_threshold = 4;

  // Window for counting failures (seconds)
  uint32 failure_window_seconds = 5;

  // Time to wait before half-open (seconds)
  uint32 reset_timeout_seconds = 6;

  // Successes needed in half-open to close (default: 1)
  optional uint32 success_threshold = 7;

  // Fallback when circuit is open (optional)
  optional StepOperation fallback = 8;

  // Custom failure condition (if absent, any error)
  optional FieldPredicate failure_if = 9;
}

// DeadLetterSpec - capture failures for later processing
message DeadLetterSpec {
  // The operation to wrap
  StepOperation inner = 1;

  // Tool to invoke on failure
  string dead_letter_tool = 2;

  // Max attempts before dead-lettering (default: 1)
  optional uint32 max_attempts = 3;

  // Backoff between attempts
  optional BackoffStrategy backoff = 4;

  // Whether to rethrow after dead-lettering
  bool rethrow = 5;
}

// SagaSpec - distributed transaction with compensation
message SagaSpec {
  // Ordered list of saga steps
  repeated SagaStep steps = 1;

  // Store for saga state (for recovery)
  optional string store = 2;

  // JSONPath to derive saga instance ID
  optional string saga_id_path = 3;

  // Timeout for entire saga in milliseconds
  optional uint32 timeout_ms = 4;

  // Output binding
  optional DataBinding output = 5;
}

message SagaStep {
  // Step identifier
  string id = 1;

  // Human-readable name
  string name = 2;

  // The action to perform
  StepOperation action = 3;

  // Compensating action (optional)
  optional StepOperation compensate = 4;

  // Input binding for this step
  DataBinding input = 5;
}

// ClaimCheckSpec - externalize large payloads
message ClaimCheckSpec {
  // Tool to store payload and return reference
  string store_tool = 1;

  // Tool to retrieve payload from reference
  string retrieve_tool = 2;

  // Inner operation operating on reference
  StepOperation inner = 3;

  // Whether to retrieve original at end
  bool retrieve_at_end = 4;
}

