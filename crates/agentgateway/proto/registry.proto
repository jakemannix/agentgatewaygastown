syntax = "proto3";

package agentgateway.dev.registry;

import "google/protobuf/struct.proto";

option go_package = "github.com/agentgateway/agentgateway/go/api;api";

// =============================================================================
// Registry Proto - Tool Composition IR
// =============================================================================
//
// This proto defines the Intermediate Representation (IR) for tool compositions.
// It is the single source of truth for the registry schema.
//
// ## Implementation Status
//
// IMPLEMENTED (Runtime Works):
//   - SourceTool: 1:1 mapping to backend tools
//   - PipelineSpec: Sequential execution with data binding
//   - ScatterGatherSpec: Parallel fan-out with aggregation
//   - FilterSpec: Predicate-based array filtering
//   - SchemaMapSpec: Field transformation and mapping
//   - MapEachSpec: Per-element array processing
//   - OutputTransform: Result field mapping
//
// IR ONLY (Types Defined, No Runtime Executor):
//   - RetrySpec: Retry with backoff
//   - TimeoutSpec: Execution time limits
//   - CacheSpec: Read-through caching
//   - IdempotentSpec: Duplicate prevention
//   - CircuitBreakerSpec: Fail-fast protection
//   - DeadLetterSpec: Failure capture
//   - SagaSpec: Distributed transactions (partial - executor exists)
//   - ClaimCheckSpec: Large payload externalization
//
// When implementing new patterns:
//   1. Add the proto message definition
//   2. Add to PatternSpec oneof
//   3. Mark as "IR only" until runtime executor is implemented
//   4. Update tests/fixtures/registry/README.md
//
// =============================================================================

// Registry is the root container for the v2 registry IR
// Contains schemas, servers, agents, and tools for full registry definition
message Registry {
  // Schema version for compatibility checking (e.g., "2.0")
  string schema_version = 1;

  // List of tool definitions (virtual tools and compositions)
  repeated ToolDefinition tools = 2;

  // Named JSON Schema definitions (v2)
  // Can be referenced by tools via "$ref": "#/schemas/<name>"
  repeated SchemaDefinition schemas = 3;

  // MCP server definitions with versioning (v2)
  // Enables version-aware routing and validation
  repeated ServerDefinition servers = 4;

  // Agent definitions for A2A routing (v2)
  // Enables agent multiplexing and agent-as-tool execution
  repeated AgentDefinition agents = 5;
}

// =============================================================================
// Schema Definitions (v2)
// =============================================================================

// SchemaDefinition represents a named, reusable JSON Schema
// Tools can reference these via "$ref": "#/schemas/<name>"
message SchemaDefinition {
  // Unique schema name (used in $ref)
  string name = 1;

  // Optional description of this schema
  optional string description = 2;

  // The JSON Schema definition
  google.protobuf.Struct schema = 3;

  // Semantic version of this schema
  optional string version = 4;

  // Optional metadata (owner, classification, deprecation info, etc.)
  map<string, google.protobuf.Value> metadata = 5;
}

// =============================================================================
// Server Definitions (v2)
// =============================================================================

// ServerDefinition represents an MCP server with versioning
// Enables version-aware routing: "server:version" key dispatch
message ServerDefinition {
  // Server name (e.g., "doc-service")
  string name = 1;

  // Server version (e.g., "1.2.0") - forms "name:version" routing key
  string version = 2;

  // Optional description of this server
  optional string description = 3;

  // Server capabilities (what protocols/features it supports)
  ServerCapabilities capabilities = 4;

  // Tools provided by this server (for validation)
  // Maps tool name -> expected input/output schema refs
  repeated ServerTool provided_tools = 5;

  // Optional metadata (owner, team, health endpoint, etc.)
  map<string, google.protobuf.Value> metadata = 6;
}

// ServerCapabilities describes what an MCP server supports
message ServerCapabilities {
  // Supports MCP StreamableHTTP protocol
  bool streamable_http = 1;

  // Supports MCP stdio protocol
  bool stdio = 2;

  // Supports SSE transport
  bool sse = 3;

  // Supports tool invocation
  bool tools = 4;

  // Supports prompts
  bool prompts = 5;

  // Supports resources
  bool resources = 6;

  // Supports sampling
  bool sampling = 7;
}

// ServerTool represents a tool provided by a server (for validation)
message ServerTool {
  // Tool name as exposed by the server
  string name = 1;

  // Expected input schema reference (e.g., "#/schemas/WeatherInput")
  optional string input_schema_ref = 2;

  // Expected output schema reference (e.g., "#/schemas/WeatherOutput")
  optional string output_schema_ref = 3;
}

// =============================================================================
// Agent Definitions (v2)
// =============================================================================

// AgentDefinition represents an agent for A2A routing
// Enables agent multiplexing and agent-as-tool execution
message AgentDefinition {
  // Unique agent name
  string name = 1;

  // Agent version (semantic versioning)
  string version = 2;

  // Human-readable description
  optional string description = 3;

  // Agent endpoint configuration
  AgentEndpoint endpoint = 4;

  // Skills/capabilities this agent provides
  repeated AgentSkill skills = 5;

  // Dependencies this agent has on other tools/agents
  repeated AgentDependency dependencies = 6;

  // Optional metadata (owner, team, cost tier, etc.)
  map<string, google.protobuf.Value> metadata = 7;
}

// AgentEndpoint describes how to connect to an agent
message AgentEndpoint {
  oneof transport {
    // A2A HTTP endpoint
    A2AEndpoint a2a = 1;

    // MCP endpoint (for MCP-native agents)
    MCPEndpoint mcp = 2;
  }
}

// A2AEndpoint for Agent-to-Agent protocol connections
message A2AEndpoint {
  // Base URL for A2A requests
  string url = 1;

  // Authentication configuration (optional)
  optional AgentAuth auth = 2;
}

// MCPEndpoint for MCP-native agent connections
message MCPEndpoint {
  // Server name reference (from servers list)
  string server = 1;

  // Server version (optional, uses latest if not specified)
  optional string server_version = 2;
}

// AgentAuth describes authentication for agent connections
message AgentAuth {
  oneof auth_type {
    // Bearer token authentication
    BearerAuth bearer = 1;

    // API key authentication
    ApiKeyAuth api_key = 2;

    // OAuth2 client credentials
    OAuth2Auth oauth2 = 3;
  }
}

message BearerAuth {
  // Token value (supports ${ENV_VAR} substitution)
  string token = 1;
}

message ApiKeyAuth {
  // Header name for the API key
  string header = 1;

  // API key value (supports ${ENV_VAR} substitution)
  string key = 2;
}

message OAuth2Auth {
  // Token endpoint URL
  string token_url = 1;

  // Client ID (supports ${ENV_VAR} substitution)
  string client_id = 2;

  // Client secret (supports ${ENV_VAR} substitution)
  string client_secret = 3;

  // Scopes to request
  repeated string scopes = 4;
}

// AgentSkill describes a capability an agent provides
// Used for capability-based routing and discovery
message AgentSkill {
  // Skill name (e.g., "code_review", "research", "data_analysis")
  string name = 1;

  // Skill description
  optional string description = 2;

  // Input schema for this skill (JSON Schema reference or inline)
  optional SchemaRef input_schema = 3;

  // Output schema for this skill
  optional SchemaRef output_schema = 4;

  // Example invocations (for LLM context)
  repeated SkillExample examples = 5;
}

// SchemaRef can be either a reference to a named schema or inline
message SchemaRef {
  oneof schema {
    // Reference to a named schema: "#/schemas/<name>"
    string ref = 1;

    // Inline JSON Schema definition
    google.protobuf.Struct inline = 2;
  }
}

// SkillExample provides example invocations for a skill
message SkillExample {
  // Example input
  google.protobuf.Value input = 1;

  // Expected output
  optional google.protobuf.Value output = 2;

  // Description of this example
  optional string description = 3;
}

// AgentDependency declares what tools/agents an agent depends on
// Used for dependency-scoped discovery (WP11)
message AgentDependency {
  oneof dependency {
    // Depends on a specific tool by name
    string tool = 1;

    // Depends on another agent by name
    string agent = 2;

    // Depends on tools from a specific server
    ServerDependency server = 3;
  }
}

// ServerDependency declares dependency on tools from a server
message ServerDependency {
  // Server name
  string name = 1;

  // Optional version constraint (semver range, e.g., ">=1.0.0 <2.0.0")
  optional string version_constraint = 2;

  // Specific tools from this server (empty means all)
  repeated string tools = 3;
}

// ToolDefinition represents either a virtual tool (1:1 mapping) or a composition (N:1 orchestration)
message ToolDefinition {
  // Name exposed to agents (unique identifier)
  string name = 1;
  
  // Optional description (for source-based, can inherit from backend)
  optional string description = 2;
  
  // Tool implementation - either source-based or composition
  oneof implementation {
    // Virtual tool: adapts a single backend tool (1:1)
    SourceTool source = 3;
    
    // Composition: orchestrates multiple tools (N:1)
    PatternSpec spec = 4;
  }
  
  // Input schema override (JSON Schema as struct)
  optional google.protobuf.Struct input_schema = 5;
  
  // Output transformation (applies to both virtual tools and compositions)
  optional OutputTransform output_transform = 6;
  
  // Semantic version of this tool definition
  optional string version = 7;
  
  // Arbitrary metadata (owner, classification, etc.)
  map<string, google.protobuf.Value> metadata = 8;
}

// SourceTool defines a 1:1 mapping to a backend tool
message SourceTool {
  // Server name (v2: references ServerDefinition.name)
  // For v1 compatibility, this is the target name in YAML config
  string server = 1;

  // Original tool name on that server
  string tool = 2;

  // Fields to inject at call time (supports ${ENV_VAR} substitution)
  map<string, google.protobuf.Value> defaults = 3;

  // Fields to remove from schema (hidden from agents)
  repeated string hide_fields = 4;

  // Server version constraint (v2)
  // If specified, forms "server:version" routing key
  // Supports semver ranges (e.g., ">=1.0.0 <2.0.0") or exact versions
  optional string server_version = 5;
}

// PatternSpec defines a composition pattern
message PatternSpec {
  oneof pattern {
    // Stateless patterns (implemented)
    PipelineSpec pipeline = 1;
    ScatterGatherSpec scatter_gather = 2;
    FilterSpec filter = 3;
    SchemaMapSpec schema_map = 4;
    MapEachSpec map_each = 5;

    // Stateful patterns (IR defined, runtime not yet implemented)
    RetrySpec retry = 20;
    TimeoutSpec timeout = 21;
    CacheSpec cache = 22;
    IdempotentSpec idempotent = 23;
    CircuitBreakerSpec circuit_breaker = 24;
    DeadLetterSpec dead_letter = 25;
    SagaSpec saga = 26;
    ClaimCheckSpec claim_check = 27;
  }
}

// =============================================================================
// Pipeline Pattern
// =============================================================================

// PipelineSpec executes steps sequentially, passing output to next step
message PipelineSpec {
  repeated PipelineStep steps = 1;
}

message PipelineStep {
  // Unique identifier for this step (for data binding references)
  string id = 1;
  
  // The operation to execute
  StepOperation operation = 2;
  
  // Input binding for this step
  DataBinding input = 3;
}

// StepOperation defines what a step does
message StepOperation {
  oneof op {
    // Call a tool by name (resolved from registry or backend)
    ToolCall tool = 1;

    // Inline pattern (no separate name)
    PatternSpec pattern = 2;

    // Call an agent (v2: for agent-as-tool execution)
    AgentCall agent = 3;
  }
}

// AgentCall invokes a registered agent as a step operation
message AgentCall {
  // Agent name (references AgentDefinition.name)
  string name = 1;

  // Specific skill to invoke (optional, uses default if not specified)
  optional string skill = 2;

  // Agent version constraint (optional, uses latest if not specified)
  optional string version = 3;
}

message ToolCall {
  // Tool name (can be virtual tool, composition, or backend tool)
  string name = 1;

  // Server name override (v2: for direct backend tool calls)
  // If specified, bypasses registry lookup and calls tool directly on server
  optional string server = 2;

  // Server version constraint (v2)
  optional string server_version = 3;
}

// DataBinding specifies where step input comes from
message DataBinding {
  oneof source {
    // From composition input
    InputBinding input = 1;

    // From a previous step's output
    StepBinding step = 2;

    // Constant value
    google.protobuf.Value constant = 3;

    // Construct an object from multiple bindings
    ConstructBinding construct = 4;
  }
}

message InputBinding {
  // JSONPath into composition input (e.g., "$" for whole input, "$.query" for field)
  string path = 1;
}

message StepBinding {
  // ID of the step to reference
  string step_id = 1;

  // JSONPath into step output
  string path = 2;
}

// ConstructBinding builds an object from multiple bindings
// Enables symmetric input construction (like outputTransform does for outputs)
message ConstructBinding {
  // Field name -> binding that produces the field value
  map<string, DataBinding> fields = 1;
}

// =============================================================================
// Scatter-Gather Pattern
// =============================================================================

// ScatterGatherSpec fans out to multiple targets in parallel and aggregates results
message ScatterGatherSpec {
  // Targets to invoke in parallel
  repeated ScatterTarget targets = 1;
  
  // How to aggregate results
  AggregationStrategy aggregation = 2;
  
  // Timeout in milliseconds (optional)
  optional uint32 timeout_ms = 3;
  
  // If true, fail immediately on first error; if false, collect partial results
  bool fail_fast = 4;
}

message ScatterTarget {
  oneof target {
    // Tool name (resolved from registry or backend)
    string tool = 1;
    
    // Inline pattern
    PatternSpec pattern = 2;
  }
}

// AggregationStrategy defines how to combine scatter-gather results
message AggregationStrategy {
  // Sequence of operations applied in order
  repeated AggregationOp ops = 1;
}

message AggregationOp {
  oneof op {
    // Flatten array of arrays into single array
    bool flatten = 1;
    
    // Sort by field
    SortOp sort = 2;
    
    // Deduplicate by field
    DedupeOp dedupe = 3;
    
    // Take first N results
    LimitOp limit = 4;
    
    // Keep arrays nested (no flattening)
    bool concat = 5;
    
    // Merge objects (for object results)
    bool merge = 6;
  }
}

message SortOp {
  // JSONPath to the field to sort by
  string field = 1;
  
  // Sort order: "asc" or "desc"
  string order = 2;
}

message DedupeOp {
  // JSONPath to the field to dedupe by
  string field = 1;
}

message LimitOp {
  // Maximum number of results
  uint32 count = 1;
}

// =============================================================================
// Filter Pattern
// =============================================================================

// FilterSpec filters array elements based on a predicate
message FilterSpec {
  // The predicate to evaluate for each element
  FieldPredicate predicate = 1;
}

message FieldPredicate {
  // JSONPath to the field to evaluate
  string field = 1;
  
  // Comparison operator: "eq", "ne", "gt", "gte", "lt", "lte", "contains", "in"
  string op = 2;
  
  // Value to compare against
  PredicateValue value = 3;
}

message PredicateValue {
  oneof value {
    string string_value = 1;
    double number_value = 2;
    bool bool_value = 3;
    bool null_value = 4;  // If true, represents null
    ValueList list_value = 5;  // For "in" operator
  }
}

message ValueList {
  repeated PredicateValue values = 1;
}

// =============================================================================
// Schema Map Pattern
// =============================================================================

// SchemaMapSpec transforms input to output using field mappings
message SchemaMapSpec {
  // Field name -> source mapping
  map<string, FieldSource> mappings = 1;
}

message FieldSource {
  oneof source {
    // JSONPath extraction from input
    string path = 1;
    
    // Constant value
    LiteralValue literal = 2;
    
    // First non-null from multiple paths
    CoalesceSource coalesce = 3;
    
    // String template with variable substitution
    TemplateSource template = 4;
    
    // Concatenate multiple fields
    ConcatSource concat = 5;
    
    // Nested object mapping
    SchemaMapSpec nested = 6;
  }
}

message LiteralValue {
  oneof value {
    string string_value = 1;
    double number_value = 2;
    bool bool_value = 3;
    bool null_value = 4;  // If true, value is null
  }
}

message CoalesceSource {
  // JSONPaths to try in order, returning first non-null
  repeated string paths = 1;
}

message TemplateSource {
  // Template string with {var} placeholders
  string template = 1;
  
  // Variable name -> JSONPath binding
  map<string, string> vars = 2;
}

message ConcatSource {
  // JSONPaths to concatenate
  repeated string paths = 1;
  
  // Separator between values (default: empty string)
  optional string separator = 2;
}

// =============================================================================
// Map Each Pattern
// =============================================================================

// MapEachSpec applies an operation to each element of an array
message MapEachSpec {
  // The operation to apply to each element
  MapEachInner inner = 1;
}

message MapEachInner {
  oneof inner {
    // Tool name to call for each element
    string tool = 1;
    
    // Pattern to apply for each element
    PatternSpec pattern = 2;
  }
}

// =============================================================================
// Output Transform
// =============================================================================

// OutputTransform defines how to transform tool/composition output
// This is the unified, enhanced version supporting all mapping features
message OutputTransform {
  // Field name -> source mapping
  map<string, FieldSource> mappings = 1;
}

// =============================================================================
// Stateful Patterns (IR defined, runtime not yet implemented)
// =============================================================================

// RetrySpec - retry with configurable backoff on failure
message RetrySpec {
  // The operation to retry
  StepOperation inner = 1;

  // Maximum attempts (including initial)
  uint32 max_attempts = 2;

  // Backoff strategy
  BackoffStrategy backoff = 3;

  // Condition to retry (if absent, retry all errors)
  optional FieldPredicate retry_if = 4;

  // Jitter factor (0.0 - 1.0)
  optional float jitter = 5;

  // Per-attempt timeout in milliseconds
  optional uint32 attempt_timeout_ms = 6;
}

message BackoffStrategy {
  oneof strategy {
    FixedBackoff fixed = 1;
    ExponentialBackoff exponential = 2;
    LinearBackoff linear = 3;
  }
}

message FixedBackoff {
  uint32 delay_ms = 1;
}

message ExponentialBackoff {
  uint32 initial_delay_ms = 1;
  uint32 max_delay_ms = 2;
  optional float multiplier = 3;  // Default: 2.0
}

message LinearBackoff {
  uint32 initial_delay_ms = 1;
  uint32 increment_ms = 2;
  uint32 max_delay_ms = 3;
}

// TimeoutSpec - enforce maximum execution duration
message TimeoutSpec {
  // The operation to wrap
  StepOperation inner = 1;

  // Timeout duration in milliseconds
  uint32 duration_ms = 2;

  // Fallback on timeout (optional)
  optional StepOperation fallback = 3;

  // Custom error message
  optional string message = 4;
}

// CacheSpec - read-through caching with TTL
message CacheSpec {
  // JSONPath expressions to derive cache key
  repeated string key_paths = 1;

  // The operation to cache
  StepOperation inner = 2;

  // Store reference name (configured in gateway)
  string store = 3;

  // TTL in seconds
  uint32 ttl_seconds = 4;

  // Stale-while-revalidate window in seconds
  optional uint32 stale_while_revalidate_seconds = 5;

  // Condition to cache result (if absent, always cache)
  optional FieldPredicate cache_if = 6;
}

// IdempotentSpec - prevent duplicate processing
message IdempotentSpec {
  // JSONPath expressions to derive idempotency key
  repeated string key_paths = 1;

  // The operation to wrap
  StepOperation inner = 2;

  // Store reference name (configured in gateway)
  string store = 3;

  // TTL in seconds (0 = no expiry)
  optional uint32 ttl_seconds = 4;

  // Behavior on duplicate
  OnDuplicate on_duplicate = 5;
}

enum OnDuplicate {
  ON_DUPLICATE_UNSPECIFIED = 0;
  ON_DUPLICATE_CACHED = 1;   // Return cached result
  ON_DUPLICATE_SKIP = 2;     // Return null/empty
  ON_DUPLICATE_ERROR = 3;    // Return error
}

// CircuitBreakerSpec - fail fast with automatic recovery
message CircuitBreakerSpec {
  // Unique name for this circuit (for state isolation)
  string name = 1;

  // The protected operation
  StepOperation inner = 2;

  // Store for circuit state
  string store = 3;

  // Number of failures to trip the circuit
  uint32 failure_threshold = 4;

  // Window for counting failures (seconds)
  uint32 failure_window_seconds = 5;

  // Time to wait before half-open (seconds)
  uint32 reset_timeout_seconds = 6;

  // Successes needed in half-open to close (default: 1)
  optional uint32 success_threshold = 7;

  // Fallback when circuit is open (optional)
  optional StepOperation fallback = 8;

  // Custom failure condition (if absent, any error)
  optional FieldPredicate failure_if = 9;
}

// DeadLetterSpec - capture failures for later processing
message DeadLetterSpec {
  // The operation to wrap
  StepOperation inner = 1;

  // Tool to invoke on failure
  string dead_letter_tool = 2;

  // Max attempts before dead-lettering (default: 1)
  optional uint32 max_attempts = 3;

  // Backoff between attempts
  optional BackoffStrategy backoff = 4;

  // Whether to rethrow after dead-lettering
  bool rethrow = 5;
}

// SagaSpec - distributed transaction with compensation
message SagaSpec {
  // Ordered list of saga steps
  repeated SagaStep steps = 1;

  // Store for saga state (for recovery)
  optional string store = 2;

  // JSONPath to derive saga instance ID
  optional string saga_id_path = 3;

  // Timeout for entire saga in milliseconds
  optional uint32 timeout_ms = 4;

  // Output binding
  optional DataBinding output = 5;
}

message SagaStep {
  // Step identifier
  string id = 1;

  // Human-readable name
  string name = 2;

  // The action to perform
  StepOperation action = 3;

  // Compensating action (optional)
  optional StepOperation compensate = 4;

  // Input binding for this step
  DataBinding input = 5;
}

// ClaimCheckSpec - externalize large payloads
message ClaimCheckSpec {
  // Tool to store payload and return reference
  string store_tool = 1;

  // Tool to retrieve payload from reference
  string retrieve_tool = 2;

  // Inner operation operating on reference
  StepOperation inner = 3;

  // Whether to retrieve original at end
  bool retrieve_at_end = 4;
}

